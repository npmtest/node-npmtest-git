{"/home/travis/build/npmtest/node-npmtest-git/test.js":"/* istanbul instrument in package npmtest_git */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-git/lib.npmtest_git.js":"/* istanbul instrument in package npmtest_git */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_git = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_git = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-git/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-git && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_git */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_git\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_git.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_git.rollup.js'] =\n            local.assetsDict['/assets.npmtest_git.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_git.__dirname + '/lib.npmtest_git.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/index.js":"[\n\t'actor', 'binary_parser', 'blame', 'blame_line', 'blob', 'commit', 'commit_stats', 'config',\n\t'diff', 'file_index', 'file_window', 'git', 'git_file_operations', 'git_index', 'git_object',\n\t'head', 'loose_storage', 'merge', 'pack_storage', 'raw_object', 'ref', 'remote', 'repo', 'repository',\n\t'status', 'status_file', 'sub_module', 'tag', 'tree', 'user_info',\n\t'internal/directory_entry', 'internal/git_blob', 'internal/git_commit', 'internal/git_tag', 'internal/git_tree'\n].forEach(function(path){\n\tvar module = require('./' + path);\n\tfor (var i in module)\n\t\texports[i] = module[i];\n});\n\n[\n\t'zlib'\n].forEach(function(path){\n\tvar module = require('../zlib/' + path);\n\tfor (var i in module)\n\t\texports[i] = module[i];\n});\n\n[\n\t'sprintf'\n].forEach(function(path){\n\tvar module = require('../sprintf/' + path);\n\tfor (var i in module)\n\t\texports[i] = module[i];\n});\n\n[\n\t'block', 'callbacks', 'change', 'diff', 'hunk'\n].forEach(function(path){\n\tvar module = require('../diff/' + path);\n\tfor (var i in module)\n\t\texports[i] = module[i];\n});\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/actor.js":"var util = require('util');\n\nActor = exports.Actor = function(name, email) {\n  var _name = name, _email = email;  \n  // Control access to internal variables\n  Object.defineProperty(this, \"name\", { get: function() { return _name; }, set: function(value) { _name = value; }, enumerable: true});    \n  Object.defineProperty(this, \"email\", { get: function() { return _email; }, set: function(value) { _email = value; }, enumerable: true});      \n}\n\nActor.from_string = function(string) {\n  if(string.match(/<.+>/)) {\n    var results = string.match(/(.*) <(.+?)>/);\n    return new Actor(results[1], results[2]);\n  } else {\n    return new Actor(string, null);\n  }\n}\n\nActor.prototype.toString = function() {\n  return this.name;\n}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/binary_parser.js":"//+ Jonas Raoni Soares Silva\n//@ http://jsfromhell.com/classes/binary-parser [v1.0]\nvar chr = String.fromCharCode;\n\nvar p = exports.BinaryParser = function( bigEndian, allowExceptions ){\n\tthis.bigEndian = bigEndian;\n\tthis.allowExceptions = allowExceptions;\n};\n\nvar Buffer = exports.BinaryParser.Buffer = function( bigEndian, buffer ){\n  this.bigEndian = bigEndian || 0;\n  this.buffer = [];\n  this.setBuffer( buffer );\n};\n\nBuffer.prototype.setBuffer = function( data ){\n\tif( data ){\n\t\tfor( var l, i = l = data.length, b = this.buffer = new Array( l ); i; b[l - i] = data.charCodeAt( --i ) );\n\t\tthis.bigEndian && b.reverse();\n\t}\n};\n\nBuffer.prototype.hasNeededBits = function( neededBits ){\n\treturn this.buffer.length >= -( -neededBits >> 3 );\n};\n\nBuffer.prototype.checkBuffer = function( neededBits ){\n\tif( !this.hasNeededBits( neededBits ) )\n\t\tthrow new Error( \"checkBuffer::missing bytes\" );\n};\n\nBuffer.prototype.readBits = function( start, length ){\n\t//shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni)\n\tfunction shl( a, b ){\n\t\tfor( ; b--; a = ( ( a %= 0x7fffffff + 1 ) & 0x40000000 ) == 0x40000000 ? a * 2 : ( a - 0x40000000 ) * 2 + 0x7fffffff + 1 );\n\t\treturn a;\n\t}\n\tif( start < 0 || length <= 0 )\n\t\treturn 0;\n\tthis.checkBuffer( start + length );\n\tfor( var offsetLeft, offsetRight = start % 8, curByte = this.buffer.length - ( start >> 3 ) - 1, lastByte = this.buffer.length + ( -( start + length ) >> 3 ), diff = curByte - lastByte, sum = ( ( this.buffer[ curByte ] >> offsetRight ) & ( ( 1 << ( diff ? 8 - offsetRight : length ) ) - 1 ) ) + ( diff && ( offsetLeft = ( start + length ) % 8 ) ? ( this.buffer[ lastByte++ ] & ( ( 1 << offsetLeft ) - 1 ) ) << ( diff-- << 3 ) - offsetRight : 0 ); diff; sum += shl( this.buffer[ lastByte++ ], ( diff-- << 3 ) - offsetRight ) );\n\treturn sum;\n};\n\t\np.warn = function( msg ){\n\tif( this.allowExceptions )\n\t\tthrow new Error( msg );\n\treturn 1;\n};\np.decodeFloat = function( data, precisionBits, exponentBits ){\n\tvar b = new this.Buffer( this.bigEndian, data );\n\tb.checkBuffer( precisionBits + exponentBits + 1 );\n\tvar bias = Math.pow( 2, exponentBits - 1 ) - 1, signal = b.readBits( precisionBits + exponentBits, 1 ), exponent = b.readBits( precisionBits, exponentBits ), significand = 0,\n\tdivisor = 2, curByte = b.buffer.length + ( -precisionBits >> 3 ) - 1;\n\tdo{\n\t\tfor( var byteValue = b.buffer[ ++curByte ], startBit = precisionBits % 8 || 8, mask = 1 << startBit; mask >>= 1; ( byteValue & mask ) && ( significand += 1 / divisor ), divisor *= 2 );\n\t}while( precisionBits -= startBit );\n\treturn exponent == ( bias << 1 ) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : ( 1 + signal * -2 ) * ( exponent || significand ? !exponent ? Math.pow( 2, -bias + 1 ) * significand : Math.pow( 2, exponent - bias ) * ( 1 + significand ) : 0 );\n};\np.decodeInt = function( data, bits, signed, forceBigEndian ){\n\tvar b = new this.Buffer( this.bigEndian||forceBigEndian, data ), x = b.readBits( 0, bits ), max = Math.pow( 2, bits );\n\treturn signed && x >= max / 2 ? x - max : x;\n};\np.encodeFloat = function( data, precisionBits, exponentBits ){\n\tvar bias = Math.pow( 2, exponentBits - 1 ) - 1, minExp = -bias + 1, maxExp = bias, minUnnormExp = minExp - precisionBits,\n\tstatus = isNaN( n = parseFloat( data ) ) || n == -Infinity || n == +Infinity ? n : 0,\n\texp = 0, len = 2 * bias + 1 + precisionBits + 3, bin = new Array( len ),\n\tsignal = ( n = status !== 0 ? 0 : n ) < 0, n = Math.abs( n ), intPart = Math.floor( n ), floatPart = n - intPart,\n\ti, lastBit, rounded, j, result;\n\tfor( i = len; i; bin[--i] = 0 );\n\tfor( i = bias + 2; intPart && i; bin[--i] = intPart % 2, intPart = Math.floor( intPart / 2 ) );\n\tfor( i = bias + 1; floatPart > 0 && i; ( bin[++i] = ( ( floatPart *= 2 ) >= 1 ) - 0 ) && --floatPart );\n\tfor( i = -1; ++i < len && !bin[i]; );\n\tif( bin[( lastBit = precisionBits - 1 + ( i = ( exp = bias + 1 - i ) >= minExp && exp <= maxExp ? i + 1 : bias + 1 - ( exp = minExp - 1 ) ) ) + 1] ){\n\t\tif( !( rounded = bin[lastBit] ) ){\n\t\t\tfor( j = lastBit + 2; !rounded && j < len; rounded = bin[j++] );\n\t\t}\n\t\tfor( j = lastBit + 1; rounded && --j >= 0; ( bin[j] = !bin[j] - 0 ) && ( rounded = 0 ) );\n\t}\n\tfor( i = i - 2 < 0 ? -1 : i - 3; ++i < len && !bin[i]; );\n\tif( ( exp = bias + 1 - i ) >= minExp && exp <= maxExp )\n\t\t++i;\n\telse if( exp < minExp ){\n\t\texp != bias + 1 - len && exp < minUnnormExp && this.warn( \"encodeFloat::float underflow\" );\n\t\ti = bias + 1 - ( exp = minExp - 1 );\n\t}\n\tif( intPart || status !== 0 ){\n\t\tthis.warn( intPart ? \"encodeFloat::float overflow\" : \"encodeFloat::\" + status );\n\t\texp = maxExp + 1;\n\t\ti = bias + 2;\n\t\tif( status == -Infinity )\n\t\t\tsignal = 1;\n\t\telse if( isNaN( status ) )\n\t\t\tbin[i] = 1;\n\t}\n\tfor( n = Math.abs( exp + bias ), j = exponentBits + 1, result = \"\"; --j; result = ( n % 2 ) + result, n = n >>= 1 );\n\tfor( n = 0, j = 0, i = ( result = ( signal ? \"1\" : \"0\" ) + result + bin.slice( i, i + precisionBits ).join( \"\" ) ).length, r = []; i; j = ( j + 1 ) % 8 ){\n\t\tn += ( 1 << j ) * result.charAt( --i );\n\t\tif( j == 7 ){\n\t\t\tr[r.length] = String.fromCharCode( n );\n\t\t\tn = 0;\n\t\t}\n\t}\n\tr[r.length] = n ? String.fromCharCode( n ) : \"\";\n\treturn ( this.bigEndian ? r.reverse() : r ).join( \"\" );\n};\np.encodeInt = function( data, bits, signed, forceBigEndian ){\n\tvar max = Math.pow( 2, bits );\n\t( data >= max || data < -( max / 2 ) ) && this.warn( \"encodeInt::overflow\" ) && ( data = 0 );\n\tdata < 0 && ( data += max );\n\tfor( var r = []; data; r[r.length] = String.fromCharCode( data % 256 ), data = Math.floor( data / 256 ) );\n\tfor( bits = -( -bits >> 3 ) - r.length; bits--; r[r.length] = \"\\0\" );\n        return ( (this.bigEndian||forceBigEndian) ? r.reverse() : r ).join( \"\" );\n};\np.toSmall    = function( data ){ return this.decodeInt( data,  8, true  ); };\np.fromSmall  = function( data ){ return this.encodeInt( data,  8, true  ); };\np.toByte     = function( data ){ return this.decodeInt( data,  8, false ); };\np.fromByte   = function( data ){ return this.encodeInt( data,  8, false ); };\np.toShort    = function( data ){ return this.decodeInt( data, 16, true  ); };\np.fromShort  = function( data ){ return this.encodeInt( data, 16, true  ); };\np.toWord     = function( data ){ return this.decodeInt( data, 16, false ); };\np.fromWord   = function( data ){ return this.encodeInt( data, 16, false ); };\np.toInt      = function( data ){ return this.decodeInt( data, 32, true  ); };\np.fromInt    = function( data ){ return this.encodeInt( data, 32, true  ); };\np.toLong     = function( data ){ return this.decodeInt( data, 64, true  ); };\np.fromLong   = function( data ){ return this.encodeInt( data, 64, true  ); };\np.toDWord    = function( data ){ return this.decodeInt( data, 32, false ); };\np.fromDWord  = function( data ){ return this.encodeInt( data, 32, false ); };\np.toQWord    = function( data ){ return this.decodeInt( data, 64, true ); };\np.fromQWord  = function( data ){ return this.encodeInt( data, 64, true ); };\np.toFloat    = function( data ){ return this.decodeFloat( data, 23, 8   ); };\np.fromFloat  = function( data ){ return this.encodeFloat( data, 23, 8   ); };\np.toDouble   = function( data ){ return this.decodeFloat( data, 52, 11  ); };\np.fromDouble = function( data ){ return this.encodeFloat( data, 52, 11  ); };\n\n// Factor out the encode so it can be shared by add_header and push_int32\np.encode_int32 = function(number) {\n  var a, b, c, d, unsigned;\n  unsigned = (number < 0) ? (number + 0x100000000) : number;\n  a = Math.floor(unsigned / 0xffffff);\n  unsigned &= 0xffffff;\n  b = Math.floor(unsigned / 0xffff);\n  unsigned &= 0xffff;\n  c = Math.floor(unsigned / 0xff);\n  unsigned &= 0xff;\n  d = Math.floor(unsigned);\n  return chr(a) + chr(b) + chr(c) + chr(d);\n};\n\np.encode_int64 = function(number) {\n  var a, b, c, d, e, f, g, h, unsigned;\n  unsigned = (number < 0) ? (number + 0x10000000000000000) : number;\n  a = Math.floor(unsigned / 0xffffffffffffff);\n  unsigned &= 0xffffffffffffff;\n  b = Math.floor(unsigned / 0xffffffffffff);\n  unsigned &= 0xffffffffffff;\n  c = Math.floor(unsigned / 0xffffffffff);\n  unsigned &= 0xffffffffff;\n  d = Math.floor(unsigned / 0xffffffff);\n  unsigned &= 0xffffffff;\n  e = Math.floor(unsigned / 0xffffff);\n  unsigned &= 0xffffff;\n  f = Math.floor(unsigned / 0xffff);\n  unsigned &= 0xffff;\n  g = Math.floor(unsigned / 0xff);\n  unsigned &= 0xff;\n  h = Math.floor(unsigned);\n  return chr(a) + chr(b) + chr(c) + chr(d) + chr(e) + chr(f) + chr(g) + chr(h);\n};\n\n/**\n  UTF8 methods\n**/\n\n// Take a raw binary string and return a utf8 string\np.decode_utf8 = function(a) {\n  var string = \"\";\n  var i = 0;\n  var c = c1 = c2 = 0;\n\n  while ( i < a.length ) {\n    c = a.charCodeAt(i);\n    if (c < 128) {\n      string += String.fromCharCode(c);\n      i++;\n    } else if((c > 191) && (c < 224)) {\n\t    c2 = a.charCodeAt(i+1);\n      string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n      i += 2;\n    } else {\n\t    c2 = a.charCodeAt(i+1);\n\t    c3 = a.charCodeAt(i+2);\n      string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n      i += 3;\n    }\n  }\n  return string;\n};\n\n// Encode a cstring correctly\np.encode_cstring = function(s) { \n  return unescape(encodeURIComponent(s)) + p.fromByte(0);\n};\n\n// Take a utf8 string and return a binary string\np.encode_utf8 = function(s) {\n  var a=\"\";\n  for (var n=0; n< s.length; n++) {\n    var c=s.charCodeAt(n);\n    if (c<128) {\n\t    a += String.fromCharCode(c);\n    } else if ((c>127)&&(c<2048)) {\n\t    a += String.fromCharCode( (c>>6) | 192) ;\n\t    a += String.fromCharCode( (c&63) | 128);\n    } else {\n      a += String.fromCharCode( (c>>12) | 224);\n      a += String.fromCharCode( ((c>>6) & 63) | 128);\n      a += String.fromCharCode( (c&63) | 128);\n    }\n  }\n  return a;\n};\n\np.pprint = function(s) {\n  var util = require('util');\n  \n  for (var i=0; i<s.length; i++) {\n    if (s.charCodeAt(i)<32) {util.puts(s.charCodeAt(i)+' : ');}\n    else {util.puts(s.charCodeAt(i)+' : '+ s.charAt(i));}\n  }\n};\n\np.hprint = function(s) {\n  var util = require('util');\n  \n  for (var i=0; i<s.length; i++) {\n    if (s.charCodeAt(i)<32) {util.puts(s.charCodeAt(i)+' : ');}\n    else {util.puts(s.charCodeAt(i).toString(16)+' : '+ s.charAt(i));}\n  }\n};\n\np.hex = function(s) {\n  var util = require('util');\n  var string = ''\n  \n  for (var i=0; i<s.length; i++) {\n    var c = s.charCodeAt(i).toString(16);\n    c = c.length == 1 ? \"0\" + c : c;\n    string = string + c;\n  }\n  \n  return string;\n};\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/blame.js":"var BlameLine = require('./blame_line').BlameLine;\n\nvar Blame = exports.Blame = function(repo, file, commit, callback) {  \n  var _repo = repo, _file = file, _commit = commit, _lines = [];\n  \n  // Unpack parameters as commit might be null\n  var args = Array.prototype.slice.call(arguments, 2);\n  callback = args.pop();\n  var _commit = args.length ? args.shift() : null;      \n  \n  // Control access to internal variables\n  Object.defineProperty(this, \"repo\", { get: function() { return _repo; }, set: function(value) { _repo = value; }, enumerable: false});    \n  Object.defineProperty(this, \"file\", { get: function() { return _file; }, set: function(value) { _file = value; }, enumerable: true});      \n  Object.defineProperty(this, \"commit\", { get: function() { return _commit; }, set: function(value) { _commit = value; }, enumerable: true});      \n  Object.defineProperty(this, \"lines\", { get: function() { return _lines; }, set: function(value) { _lines = value; }, enumerable: true});      \n  \n  // Load the blame object\n  load_blame(this, _repo, _file, _commit, callback);\n}\n\n// Load and parse the blame\nvar load_blame = function(blame, repo, file, commit, callback) {\n  repo.git.blame({p:true}, commit, '--', file, function(err, blame_output) {\n    process_raw_blame(blame, blame_output, repo, callback)\n  });\n}\n\n// Parse the output and set all parameters on the current blame object\nvar process_raw_blame = function(blame, output, repo, callback) {\n  // Cleanup the output (removing whitespace at the start and end)\n  output = output ? output.trim() : '';\n  // Set up variables\n  var lines = [], final = [];\n  var info = {}, commits = [];\n  \n  var output_lines = output.split(\"\\n\");\n  for(var i = 0; i < output_lines.length; i++) {\n    var line = output_lines[i];\n    var match = line.match(/^(\\w{40}) (\\d+) (\\d+)/);\n    \n    // If we have a tab character at the start skip it\n    if(line.substr(0, 1) == \"\\t\") {\n      lines.push(line.substring(1, line.length));\n    } else if(match) {\n      if(!commits[match[1]]) {\n        repo.commit(match[1], function(err, commit) {\n          commits[match[1]] = commit;          \n        });\n      }\n      // Add the info for this line\n      info[parseInt(match[3])] = [commits[match[1]], parseInt(match[2])];\n    }\n  }\n\n  // Let's sort the content\n  var sorted_keys = Object.keys(info).sort(function(a, b) { return parseInt(a) - parseInt(b); });\n  sorted_keys.forEach(function(key) {\n    var info_object = info[key];\n    final.push(new BlameLine(key, info_object[1], info_object[0], lines[key - 1]));\n  });\n  // Assign the blame lines to the blame object and return\n  blame.lines = final;\n  callback(null, blame);\n}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/blame_line.js":"var BlameLine = exports.BlameLine = function(lineno, oldlineno, commit, line) {\n  var _lineno = lineno, _oldlineno = oldlineno, _commit = commit, _line = line;\n  \n  \n  // Control access to internal variables\n  Object.defineProperty(this, \"lineno\", { get: function() { return _lineno; }, set: function(value) { _lineno = value; }, enumerable: true});    \n  Object.defineProperty(this, \"oldlineno\", { get: function() { return _oldlineno; }, set: function(value) { _oldlineno = value; }, enumerable: true});    \n  Object.defineProperty(this, \"commit\", { get: function() { return _commit; }, set: function(value) { _commit = value; }, enumerable: true});    \n  Object.defineProperty(this, \"line\", { get: function() { return _line; }, set: function(value) { _line = value; }, enumerable: true});      \n}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/blob.js":"var mime = require('mime'),\n  Actor = require('./actor').Actor;  \n\nvar Blob = exports.Blob = function(repo, id, mode, name) {\n  var _repo = repo, _id = id, _mode = mode, _name = name, _content = null, _data = null, _size = 0;\n  \n  Object.defineProperty(this, \"repo\", { get: function() { return _repo; }, set: function(value) { _repo = value; }, enumerable: true});\n  Object.defineProperty(this, \"id\", { get: function() { return _id; }, set: function(value) { _id = value; }, enumerable: true});\n  Object.defineProperty(this, \"mode\", { get: function() { return _mode; }, set: function(value) { _mode = value; }, enumerable: true});\n  Object.defineProperty(this, \"name\", { get: function() { return _name; }, set: function(value) { _name = value; }, enumerable: true});\n  Object.defineProperty(this, \"content\", { get: function() { return _content; }, set: function(value) { _content = value; }, enumerable: true});\n\n  // Data of the blob\n  Object.defineProperty(this, \"data\", { get: function() { \n      _data = lazy_reader(_repo, _id, 'p', _data); \n      return _data;\n    }, enumerable: false});\n\n  // Size of the blob\n  Object.defineProperty(this, \"size\", { get: function() { \n      _size = lazy_reader(_repo, _id, 's', _size); \n      return _size;\n    }, enumerable: false});\n\n  // Size of the blob\n  Object.defineProperty(this, \"mime_type\", { get: function() {\n      return mime.lookup(_name || '', 'text/plain')\n    }, enumerable: false});\n  \n  // Return the base name\n  Object.defineProperty(this, \"basename\", { get: function() { \n      if(_name) {\n        var parts = _name.split(\"/\");\n        return parts[parts.length - 1];\n      } else {\n        return null;\n      }\n    }, enumerable: false});\n}\n\nvar lazy_reader = function(repo, id, type, variable) {\n  if(variable) return variable;\n  // Control the flow\n  var done = false;\n  var value = null;\n  \n  // Fetch the content\n  repo.git.cat_file(type, id, function(err, content) {\n    if(err) return done = true;\n    value = content;\n    done = true;\n  })\n  \n  while(!done) {};\n  return value;  \n}\n\n// The blame information for the given file at the given commit\n//\n// Returns array of commit and array of lines\nBlob.blame = function(repo, commit, file, callback) {\n  var Commit = require('./commit').Commit;\n  \n  repo.git.blame({'p':true}, commit, '--', file, function(err, data) {\n    if(err) return callback(err, data);\n    \n    // Variables stored\n    var commits = {};\n    var blames = [];\n    var info = null;\n    \n    // Split up and parse the output\n    var lines = data.split(\"\\n\");\n    lines.forEach(function(line) {\n      var parts = line.split(/\\s+/);\n      if(parts.length > 0) {\n        var part = parts[0];\n\n        // Process the part\n        if(part.match(/^[0-9A-Fa-f]{40}$/)) {\n          // Parse references to SHA keys\n          if(line.match(/^([0-9A-Fa-f]{40}) (\\d+) (\\d+) (\\d+)$/)) {\n            var matches = line.match(/^([0-9A-Fa-f]{40}) (\\d+) (\\d+) (\\d+)$/);\n            var id = matches[1];\n            var origin_line = matches[2];\n            var final_line = matches[3];\n            var group_lines = matches[4];\n            // Set if of the current reference\n            info = {id:id};\n            blames.push([null, []]);\n          } else if(line.match(/^([0-9A-Fa-f]{40}) (\\d+) (\\d+)$/)) {\n            var matches = line.match(/^([0-9A-Fa-f]{40}) (\\d+) (\\d+)$/);\n            var id = matches[1];\n            var origin_line = matches[2];\n            var final_line = matches[3];            \n            // Set if of the current reference\n            info = {id:id};\n          }          \n        } else if(part.match(/^(author|committer)/)) {\n          if(part.match(/^(.+)-mail$/)) {\n            info[part.match(/^(.+)-mail$/)[1] + \"_email\"] = parts[parts.length - 1];\n          } else if(part.match(/^(.+)-time$/)) {            \n            info[part.match(/^(.+)-time$/)[1] + \"_date\"] = new Date(parseInt(parts[parts.length - 1]) * 1000);\n          } else if(part.match(/^(author|committer)$/)) {\n            info[part.match(/^(author|committer)$/)[1]] = parts.slice(1).join(\" \");\n          }          \n        } else if(part.match(/^filename/)) {\n          info['filename'] = parts[parts.length - 1];\n        } else if(part.match(/^summary/)) {          \n          info['summary'] = parts.slice(1).join(\" \").replace('\\n', '');\n        } else if(part == '') {\n          var commit = commits[info[\"id\"]];\n          // Create new commit\n          if(!commit) {\n            // commit = new Commit(repo, )\n            var id = info['id'];\n            var author = Actor.from_string(info['author'] + ' ' + info['author_email']);\n            var authored_date = info['author_date'];\n            var committer = Actor.from_string(info['committer'] + ' ' + info['committer_email']);\n            var committed_date = info['committer_date'];\n            var message = info['summary'];            \n            // Create a new commit\n            commit = new Commit(repo, id, null, null, author, authored_date, committer, committed_date, message);\n            commits[info['id']] = commit;\n          }\n          \n          // Break up the parts\n          parts = line.match(/^\\t(.*)$/);\n          blames[blames.length - 1][0] = commit;\n          blames[blames.length - 1][1].push(parts[1]);\n          info = null;\n        }\n      }\n    });    \n    // Call back with the list of blames\n    callback(null, blames);\n  });\n}\n\n\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/commit.js":"var util = require('util'),\n  Actor = require('./actor').Actor,\n  Diff = require('./diff').Diff;\n  Tree = require('./tree').Tree;\n\n// Create a commit object\nvar Commit = exports.Commit = function(repo, id, parents, tree, author, authored_date, committer, committed_date, message, filechanges) {\n  var _repo = repo, _id = id, _parents = parents, _tree = tree, _author = author, _authored_date = authored_date;\n  var _committer = committer, _committed_date = committed_date, _id_abbrev = null, _filechanges = filechanges;\n  // Ensure we have an empty message at least\n  message = message ? message : [];\n  message = Array.isArray(message) ? message : [message];\n  var _message = message.join(\"\\n\");\n  // Extract short message\n  var message_lines_filtered = message.filter(function(line) {\n    return line.trim() == '' ? false : true;\n  })\n  var _short_message = message_lines_filtered.length > 0 ? message_lines_filtered[0] : '';\n  // Internal properties\n  Object.defineProperty(this, \"repo\", { get: function() { return _repo; }, set: function(value) { _repo = value; }, enumerable: true, configurable:true});\n  Object.defineProperty(this, \"id\", { get: function() { return _id; }, set: function(value) { _id = value; }, enumerable: true, configurable:true});\n  Object.defineProperty(this, \"sha\", { get: function() { return _id; }, set: function(value) { _id = value; }, enumerable: true, configurable:true});\n  Object.defineProperty(this, \"parents\", { get: function() {\n      _parents = lazy_reader(_repo, _id, 'parents', _parents);\n      return _parents;\n    }, set: function(value) { _parents = value; }, enumerable: true, configurable:true});\n  Object.defineProperty(this, \"tree\", { get: function() {\n      _tree = lazy_reader(_repo, _id, 'tree', _tree);\n      return _tree;\n    }, set: function(value) { _tree = value; }, enumerable: true, configurable:true});\n  Object.defineProperty(this, \"author\", { get: function() {\n      _author = lazy_reader(_repo, _id, 'author', _author);\n      return _author;\n    }, set: function(value) { _author = value; }, enumerable: true, configurable:true});\n  Object.defineProperty(this, \"authored_date\", { get: function() {\n      _authored_date = lazy_reader(_repo, _id, 'authored_date', _authored_date);\n      return _authored_date;\n    }, set: function(value) { _authored_date = value; }, enumerable: true, configurable:true});\n  Object.defineProperty(this, \"committer\", { get: function() {\n      _committer = lazy_reader(_repo, _id, 'comitter', _committer);\n      return _committer;\n    }, set: function(value) { _comitter = value; }, enumerable: true, configurable:true});\n  Object.defineProperty(this, \"committed_date\", { get: function() {\n      _committed_date = lazy_reader(_repo, _id, 'committed_date', _committed_date);\n      return _committed_date;\n    }, set: function(value) { _committed_date = value; }, enumerable: true, configurable:true});\n  Object.defineProperty(this, \"message\", { get: function() {\n      _message = lazy_reader(_repo, _id, 'message', _message);\n      return _message;\n    }, set: function(value) { _message = value; }, enumerable: true, configurable:true});\n  Object.defineProperty(this, \"short_message\", { get: function() {\n      _short_message = lazy_reader(_repo, _id, 'short_message', _short_message);\n      return _short_message;\n    }, set: function(value) { _short_message = value; }, enumerable: true, configurable:true});\n  Object.defineProperty(this, \"filechanges\", { get: function() {\n      _filechanges = lazy_reader(_repo, _id, 'filechanges', _filechanges);\n      return _filechanges;\n    }, set: function(value) { _filechanges = value; }, enumerable: true, configurable:true});\n\n  Object.defineProperty(this, \"_id_abbrev\", { get: function() { return _id_abbrev; }, set: function(value) { _id_abbrev = value; }, enumerable: true, configurable:true});\n}\n\nvar lazy_reader = function(repo, id, name, variable) {\n  if(variable != null) return variable;\n  // Control the flow\n  var done = false;\n  var value = null;\n  // Fetch all the commits\n  Commit.find_all(repo, id, {max_count:1}, function(err, commits) {\n    if(err) return done = true;\n    value = commits[0][name];\n    done = true;\n  })\n\n  while(!done) {};\n  return value ? value : '';\n}\n\n// Load a commit\nCommit.prototype.load = function(callback) {\n  var self = this;\n\n  Commit.find_all(this.repo, this.id, {max_count:1}, function(err, commits) {\n    if(err) return callback(err, commits);\n    var commit = commits[0];\n    Object.keys(commit).forEach(function(key) {\n      self[key] = commit[key];\n    });\n    callback(null, self);\n  });\n}\n\n// Chomp text removing end carriage returns\nvar chomp = function chomp(raw_text) {\n  return raw_text.replace(/(\\n|\\r)+$/, '');\n}\n\n// Fetch the short form of an id\nCommit.prototype.id_abbrev = function(callback) {\n  var self = this;\n\n  if(this._id_abbrev) return callback(null, this._id_abbrev);\n  this.repo.git.rev_parse({}, this.id, 0, function(err, id) {\n    if(err) return callback(err, id);\n    self._id_abbrev = chomp(id).substr(0, 7);\n    callback(null, self._id_abbrev);\n  })\n}\n\n// Parse the actor and create the object\nvar actor = function(line) {\n  var results = line.match(/^.+? (.*) (\\d+) .*$/);\n  var actor = results[1];\n  var epoch = results[2];\n  // Return the objects\n  return [Actor.from_string(actor), new Date(parseInt(epoch) * 1000)]\n}\n\n// Convert commit text to list of commits\nCommit.list_from_string = function(repo, text) {  \n  // Split up the result\n  var lines = text.split(\"\\n\");\n  \n  // require('util').debug(\"-------------------------------------------------- lines\")\n  // require('util').debug(require('util').inspect(lines))\n  // require('util').debug(\"-------------------------------------------------- text end\")\n  \n  var linesshift = function() {\n    return lines.shift();\n  };\n  var commits = [];\n  // Parse all commit messages\n  while(lines.length > 0) {\n    var id = linesshift().split(/ /).pop();\n    if(lines.length == 0) break;\n    var tree = new Tree(repo, linesshift().split(/ /).pop());\n\n    // Let's get the parents\n    var parents = [];\n    while(lines[0].match(/^parent/)) {\n      parents.push(new Commit(repo, linesshift().split(/ /).pop()))\n    }\n    // Let's get the author and committer\n    var actor_info = actor(linesshift());\n    var author = actor_info[0];\n    var authored_date = actor_info[1]\n    var committer_info = actor(linesshift());\n    var comitter = committer_info[0];\n    var committed_date = committer_info[1];\n    // Unpack encoding\n    var encoding = lines[0].match(/^encoding/) ? linesshift().split().pop() : '';\n    // Jump empty space\n    linesshift();\n    // Unpack message lines\n    var message_lines = [];\n    while(lines.length > 0 && lines[0].match(/^ {4}/)) {\n      var message_line = linesshift();\n      message_lines.push(message_line.substring(4, message_line.length)) ;\n    }\n\n    linesshift();\n    // Parse --raw lines\n    var filechanges = {};\n    var fcre = /:(\\d+) (\\d+) ([a-z0-9]+) ([a-z0-9]+) (\\S+)\\s+(.+)/;\n    var numre = /(\\S+)\\s+(\\S+)\\s+(.+)/;\n    var line;\n    var matched;\n    while (lines.length > 0) {\n        line = linesshift();\n        matched = line.match(fcre);\n        if (!matched) break;\n        var o = {};\n        var xs = ['a_mode', 'b_mode', 'a_blob', 'b_blob', 'what', 'path'];\n        for(var i = 0; i < xs.length; i++) {\n            o[xs[i]] = matched[i+1];\n        }\n        filechanges[o.path] = o;\n    }\n    while (line) {\n        matched = line.match(numre);\n        if (!matched) break;\n        var o = {};\n        var xs = ['plus', 'minus', 'path'];\n        for(var i = 0; i < xs.length; i++) {\n            o[xs[i]] = matched[i+1];\n        }\n        filechanges[o.path].plus = o.plus;\n        filechanges[o.path].minus = o.minus;\n        if (lines.length == 0) break;\n        line = linesshift();\n    }\n\n    if (!matched && line) lines = [line].concat(lines);\n    // Move and point to next message\n    while(lines[0] != null && lines[0] == '') linesshift();\n    // Create commit object\n    commits.push(new Commit(repo, id, parents, tree, author, authored_date, comitter, committed_date, message_lines, filechanges));\n  }\n  // Return all the commits\n  return commits;\n}\n\n// Locate all commits for a give set of parameters\nCommit.find_all = function(repo, reference, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  reference = args.length ? args.shift() : null;\n  options = args.length ? args.shift() : {};\n\n  // Merge the options with the default_options\n  if(!options.pretty) options['pretty'] = 'raw';\n  // If we have a reference use that for the lookup\n  if(!reference) options['all'] = true;\n\n  // Locate revisions\n  if(reference) {\n    repo.git.rev_list(options, reference, function(err, revision_output) {\n      if(err) return callback(err, []);\n      // Turn string into a list of revisions\n      callback(null, Commit.list_from_string(repo, revision_output));\n    });\n  } else {\n    repo.git.rev_list(options, function(err, revision_output) {\n      if(err) return callback(err, []);\n      // Turn string into a list of revisions\n      callback(null, Commit.list_from_string(repo, revision_output));\n    });\n  }\n}\n\n// Return the count of committs for a given start\nCommit.count = function(repo, ref, callback) {\n  repo.git.rev_list({}, ref, function(err, revision_output) {\n    if(err) return callback(err, revision_output);\n    callback(null, parseInt((revision_output.length/41)));\n  })\n}\n\n// Show diffs between two trees\n//  repo: the repo object\n//  a: named commit\n//  b: optional named commit, passing an array assumes you wish to omit the second\n//     named commit and limit the diff to the given paths\n//  paths: an array of paths to limit the diff.\n//\n// Returns array of diffs (baked)\nCommit.diff = function(repo, a, b, paths, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 2);\n  callback = args.pop();\n  b = args.length ? args.shift() : null;\n  paths = args.length ? args.shift() : [];\n\n  // If b is an array we skipped the b parameter\n  if(Array.isArray(b)) {\n    paths = b;\n    b = null;\n  }\n\n  // Set up parameters correctly\n  if(paths.length > 0) {\n    if(paths.length > 0) paths.unshift(\"--\");\n    if(b) paths.unshift(b);\n    paths.unshift(a);\n    // Let's execute the native git function\n    repo.git.call_git('', 'diff', '', {full_index:true}, paths, function(err, text) {\n      // Create a list of diffs from the string\n      if(text) {\n        Diff.list_from_string(repo, text, callback);\n      } else {\n        callback(null, []);\n      }\n    });\n  } else {\n    repo.git.diff(a, b, {full_index:true}, function(err, text) {\n      // Create a list of diffs from the string\n      if(text) {\n        Diff.list_from_string(repo, text, callback);\n      } else {\n        callback(null, []);\n      }\n    });\n  }\n}\n\nvar process_diff = function(repo, diff, callback) {\n  if(diff.match(/diff --git a/)) {\n    diff = diff.substring(diff.match(/diff --git a/).index, diff.length);\n  } else {\n    diff = '';\n  }\n  // Return the diffs\n  Diff.list_from_string(repo, diff, callback);\n}\n\n// Show the commits\nCommit.prototype.show = function(callback) {\n  var parents = this.parents;\n  var diff = null\n  var self = this;\n\n  if(parents.length > 1) {\n    this.repo.git.native_call(\"diff \" + parents[0].id + \"...\" + parents[1].id, {full_index:true}, function(err, diff) {\n      if(err) return callback(err, diff);\n      process_diff(this.repo, diff, callback);\n    });\n  } else {\n    this.repo.git.show({full_index:true, pretty:'raw'}, this.id, function(err, diff) {\n      if(err) return callback(err, diff);\n      process_diff(this.repo, diff, callback);\n    });\n  }\n}\n\n// Return the diffs for a commit\nCommit.prototype.diffs = function(callback) {\n  var parents = this.parents;\n  // If we have no parents\n  if(parents.length == 0) {\n    this.show(callback);\n  } else {\n    Commit.diff(this.repo, parents[0].id, this.id, callback)\n  }\n}\n\n// To String method\nCommit.prototype.toString = function() {\n  return this.id;\n}\n\n// Convert commit into patch\nCommit.prototype.toPatch = function(callback) {\n  this.repo.git.format_patch({'1':true, stdout:true}, this.id, callback);\n}\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/diff.js":"var Blob = require('./blob').Blob;\n\nvar Diff = exports.Diff = function(repo, a_path, b_path, a_blob, b_blob, a_mode, b_mode, new_file, deleted_file, diff) {\n  var _repo = repo, _a_path = a_path, _b_path = b_path\n  var _a_mode = a_mode, _b_mode = b_mode, _diff = diff;\n  // Create blob objects\n  var _a_blob = !a_blob || a_blob.match(/^0{40}$/) ? null : new Blob(repo, a_blob);\n  var _b_blob = !b_blob || b_blob.match(/^0{40}$/) ? null : new Blob(repo, b_blob);\n  // Chec if we have a new_file/deleted_file\n  var _new_file = new_file || _a_blob == null;\n  var _deleted_file = deleted_file || _b_blob == null;\n\n  Object.defineProperty(this, \"repo\", { get: function() { return _repo; }, enumerable: true});\n  Object.defineProperty(this, \"a_path\", { get: function() { return _a_path; }, enumerable: true});\n  Object.defineProperty(this, \"b_path\", { get: function() { return _b_path; }, enumerable: true});\n  Object.defineProperty(this, \"a_mode\", { get: function() { return _a_mode; }, enumerable: true});\n  Object.defineProperty(this, \"b_mode\", { get: function() { return _b_mode; }, enumerable: true});\n  Object.defineProperty(this, \"diff\", { get: function() { return _diff; }, enumerable: true});\n  Object.defineProperty(this, \"a_blob\", { get: function() { return _a_blob; }, enumerable: true});\n  Object.defineProperty(this, \"b_blob\", { get: function() { return _b_blob; }, enumerable: true});\n  Object.defineProperty(this, \"new_file\", { get: function() { return _new_file; }, enumerable: true});\n  Object.defineProperty(this, \"deleted_file\", { get: function() { return _deleted_file; }, enumerable: true});\n}\n\n// Create a list of diffs from a diff text\nDiff.list_from_string = function(repo, text, callback) {\n  // Ensure we don't have white space at the end\n  text = text.trim();\n  // Split the text into lines\n  var lines = text.split(\"\\n\");\n  var diffs = [];\n  var a_path, b_path, a_mode, b_mode, new_file = false, deleted_file = false;\n  var a_blob, b_blob;\n\n  while(text.length > 0 && lines.length > 0) {\n    // Extract a line\n    var parts = lines.shift().match(/^diff --git a\\/(.+?) b\\/(.+)$/);\n    // Unpack parts\n    var a_path = parts[1];\n    var b_path = parts[2];\n\n    if(lines[0].match(/^old mode/)) {\n      a_mode = lines.shift().match(/^old mode (\\d+)/)[1]\n      b_mode = lines.shift().match(/^new mode (\\d+)/)[1]\n    }\n\n    if(lines.length == 0 || lines[0].match(/^diff --git/)) {\n      diffs.push(new Diff(repo, a_path, b_path, null, null, a_mode, b_mode, false, false, null));\n    } else {\n      if(lines[0].match(/^new file/)) {\n        b_mode = lines.shift().match(/^new file mode (.+)$/)[1];\n        a_mode = null;\n        new_file = true;\n      } else if(lines[0].match(/^deleted file/)) {\n        a_mode = lines.shift().match(/^deleted file mode (.+)$/)[1];\n        b_mode = null;\n        deleted_file = true;\n      }\n      // Unpack index reference\n      parts = lines.shift().match(/^index ([0-9A-Fa-f]+)\\.\\.([0-9A-Fa-f]+) ?(.+)?$/);\n      a_blob = parts[1];\n      b_blob = parts[2];\n      b_mode = parts[3];\n\n      // Contains all the diff lines\n      var diff_lines = [];\n      // Fetch all the diff lines\n      while(lines.length > 0 && !lines[0].match(/^diff/)) {\n        diff_lines.push(lines.shift());\n      }\n\n      // Join the difflines\n      var diff = diff_lines.join(\"\\n\");\n      // Add the diff to the list\n      diffs.push(new Diff(repo, a_path, b_path, a_blob, b_blob, a_mode, b_mode, new_file, deleted_file, diff));\n    }\n  }\n\n  // Return the list of diffs\n  callback(null, diffs);\n}\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/tree.js":"var util = require('util'),\n  Submodule = require('./sub_module').Submodule,\n  Blob = require('./blob').Blob;\n\nvar Tree = exports.Tree = function(repo, id, mode, name, contents) {\n  var _repo = repo, _id = id, _contents = contents, _mode = mode, _name = name;\n\n  // Internal properties\n  Object.defineProperty(this, \"repo\", { get: function() { return _repo; }, set: function(value) { _repo = value; }, enumerable: true});    \n  Object.defineProperty(this, \"id\", { get: function() { return _id; }, set: function(value) { _id = value; }, enumerable: true});    \n  Object.defineProperty(this, \"mode\", { get: function() { return _mode; }, set: function(value) { _mode = value; }, enumerable: true});    \n  Object.defineProperty(this, \"name\", { get: function() { return _name; }, set: function(value) { _name = value; }, enumerable: true});    \n  Object.defineProperty(this, \"contents\", { get: function() { \n      _contents = lazy_reader(_repo, _id, 'contents', _contents); \n      return _contents;\n    }, set: function(value) { _contents = value; }, enumerable: true});\n    \n  // Return the base name\n  Object.defineProperty(this, \"basename\", { get: function() { \n      if(_name) {\n        var parts = _name.split(\"/\");\n        return parts[parts.length - 1];\n      } else {\n        return null;\n      }\n    }, enumerable: false});      \n}\n\nvar lazy_reader = function(repo, id, type, variable) {\n  if(variable != null) return variable;\n  // Control the flow\n  var done = false;\n  var value = [];\n  \n  // Fetch the content\n  repo.git.ls_tree(id, [], {}, function(err, text) {\n    if(err) return done = true;\n    // Split the output\n    var lines = text.split(\"\\n\");\n    // Create objects for all the entries\n    for(var i = 0; i < lines.length; i++) {\n      Tree.content_from_string(repo, lines[i], function(err, entry) {\n        value.push(entry);\n      });        \n    }  \n        \n    done = true;\n  })\n  \n  while(!done) {};\n  return value ? value : '';  \n}\n\n// Construct the contents of the tree\n// repo: the current rep\n// treeish: the reference\n// paths: optional array of directory paths to restrict the tree\nTree.construct = function(repo, treeish, paths, callback) {\n  // Set the path to the default if it's null\n  paths = paths ? paths : [];  \n  // Run the ls_tree command\n  repo.git.ls_tree(treeish, paths, function(err, output) {    \n    if(err) return callback(err, output);\n    construct_initialize(repo, treeish, output, callback);\n  });  \n}\n\n// Create a new instance of the tree class\nvar construct_initialize = function(repo, id, text, callback) {\n  // Create a tree object\n  var tree = new Tree(repo, id, null, null, []);  \n  var lines = text.trim().split(\"\\n\");\n  if(lines.length == 1 && lines[0] == '') lines = [];  \n  // Fetch all the lines\n  for(var i = 0; i < lines.length; i++) {\n    Tree.content_from_string(repo, lines[i], function(err, entry) {\n      if(err) return callback(err, entry);\n      tree.contents.push(entry);      \n    });        \n  }\n\n  // Remove all the null entries\n  tree.contents = tree.contents.filter(function(entry) { return entry ? true : false; });  \n  // Return the object\n  callback(null, tree);\n}\n\nTree.content_from_string = function(repo, text, callback) {\n  // Split the text into parts and extract the variables\n  var parts = text.replace(/\\t/, ' ').split(\" \");\n  var mode = parts[0];\n  var type = parts[1];\n  var id = parts[2];\n  var name = parts[3];\n  \n  if(type == \"tree\") {\n    callback(null, new Tree(repo, id, mode, name));\n  } else if(type == \"blob\") {\n    callback(null, new Blob(repo, id, mode, name));\n  } else if(type == \"link\") {\n    callback(null, new Blob(repo, id, mode, name));\n  } else if(type == \"commit\") {\n    callback(null, new Submodule(repo, id, mode, name));\n  } else {\n    callback(\"invalid type: \" + type, null);\n  } \n}\n\n// Find the named object in this tree's contents\n//\n// Examples\n//   Repo.new('/path/to/grit').tree/'lib'\n//   // => //<Grit::Tree \"6cc23ee138be09ff8c28b07162720018b244e95e\">\n//   Repo.new('/path/to/grit').tree/'README.txt'\n//   // => //<Grit::Blob \"8b1e02c0fb554eed2ce2ef737a68bb369d7527df\">\n//\n// Returns Grit::Blob or Grit::Tree or nil if not found\nTree.prototype.find = function(file) {\n  var self = this;\n  \n  if(file.match(/\\//)) {\n    var paths = file.split('/');\n    paths.length > 0 && paths[paths.length - 1] == '' ? paths.pop() : null;\n    return paths.map(function(x) {\n      return self && (self = self.find(x));\n    });\n  } else {\n    var results = self.contents.filter(function(c) {\n      return c.name == file;\n    })   \n    \n    return results.length == 1 ? results[0] : null;\n  }\n}\n\nTree.create = function(repo, attributes, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  attributes = args.length ? args.shift() : {};\n  \n  var tree = new Tree(repo);\n  for(var name in attributes) {\n    tree[name] = attributes[name];\n  }\n  \n  callback(null, tree);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/sub_module.js":"var util = require('util');\n\nvar Submodule = exports.Submodule = function(repo, id, mode, name) {\n  var _repo = repo, _id = id, _mode = mode, _name = name;\n  \n  Object.defineProperty(this, \"repo\", { get: function() { return _repo; }, set: function(value) { _repo = value; }, enumerable: true});    \n  Object.defineProperty(this, \"id\", { get: function() { return _id; }, set: function(value) { _id = value; }, enumerable: true});    \n  Object.defineProperty(this, \"mode\", { get: function() { return _mode; }, set: function(value) { _mode = value; }, enumerable: true});      \n  Object.defineProperty(this, \"name\", { get: function() { return _name; }, set: function(value) { _name = value; }, enumerable: true});    \n  \n  // Return the base name\n  Object.defineProperty(this, \"basename\", { get: function() { \n      if(_name) {\n        var parts = _name.split(\"/\");\n        return parts[parts.length - 1];\n      } else {\n        return null;\n      }\n    }, enumerable: false});  \n}\n\n// Create a Submodule containing just the specified attributes\n//   +repo+ is the Repo\n//   +atts+ is a Hash of instance variable data\n//\n// Returns Grit::Submodule (unbaked)\nSubmodule.create = function(repo, attributes, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  attributes = args.length ? args.shift() : {};\n  \n  var submodule = new Submodule(repo);\n  for(var name in attributes) {\n    submodule[name] = attributes[name];\n  }\n  \n  callback(null, submodule);\n}\n\n// The configuration information for the given +repo+\n//   +repo+ is the Repo\n//   +ref+ is the committish (defaults to 'master')\n//\n// Returns a Hash of { <path:String> => { 'url' => <url:String>, 'id' => <id:String> } }\n// Returns {} if no .gitmodules file was found\nSubmodule.config = function(repo, ref, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  ref = args.length ? args.shift() : 'master';\n\n  // Fetch code\n  repo.commit(ref, function(err, commit) {\n    if(err) return callback(err, commit);\n    // Fetch the blob\n    var blob = commit.tree.find('.gitmodules');\n    // If there is no blob return an empty object\n    if(blob == null) return callback(null, {});\n    // Parse all the lines\n    var lines = blob.data.trim().replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n    var config = {};\n    var current = null;\n    \n    lines.forEach(function(line) {\n      if(line.match(/^\\[submodule \"(.+)\"\\]$/)) {\n        var parts = line.match(/^\\[submodule \"(.+)\"\\]$/);\n        current = parts[1];\n        config[current] = {};\n        config[current]['id'] = commit.tree.find(current).id;\n      } else if(line.match(/^\\t(\\w+) = (.+)$/)) {\n        var parts = line.match(/^\\t(\\w+) = (.+)$/);\n        config[current][parts[1]] = parts[2];\n        if(parts[1] == 'path') {\n          config[current]['id'] = commit.tree.find(parts[2]).id;          \n        }\n      } else {}      \n    });\n    // Return the config\n    callback(null, config);    \n  });\n}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/commit_stats.js":"var CommitStats = exports.CommitStats = function(repo, id, files) {\n  var _repo = repo, _id = id, _files = files, _additions = 0, _deletions = 0, _total = 0;\n  \n  // Build the stats based on the files\n  _additions = files.reduce(function(previousValue, currentValue, index, array) { return previousValue + currentValue[1]; }, 0);\n  _deletions = files.reduce(function(previousValue, currentValue, index, array) { return previousValue + currentValue[2]; }, 0);\n  _total = files.reduce(function(previousValue, currentValue, index, array) { return previousValue + currentValue[3]; }, 0);\n  \n  // Internal properties\n  Object.defineProperty(this, \"repo\", { get: function() { return _repo; }, set: function(value) { _repo = value; }, enumerable: false});    \n  Object.defineProperty(this, \"id\", { get: function() { return _id; }, set: function(value) { _id = value; }, enumerable: true});    \n  Object.defineProperty(this, \"files\", { get: function() { return _files; }, set: function(value) { _files = value; }, enumerable: true});    \n  Object.defineProperty(this, \"additions\", { get: function() { return _additions; }, set: function(value) { _additions = value; }, enumerable: true});    \n  Object.defineProperty(this, \"deletions\", { get: function() { return _deletions; }, set: function(value) { _deletions = value; }, enumerable: true});    \n  Object.defineProperty(this, \"total\", { get: function() { return _total; }, set: function(value) { _total = value; }, enumerable: true});      \n}\n\n// Find all commit stats matching the given criteria\n//  repo: the repo\n//  ref: the ref from which to begin (SHA1 or name) or nil for all\n//  options: hash of optional arguments to git\n//    max_count: maximum number of commits to fetch\n//    skip: number of commits to skip\n//\n// Returns assoc array (all values are lazy loading)\nCommitStats.find_all = function(repo, reference, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 2);\n  callback = args.pop();  \n  var self = this;\n  // Unpack variables\n  options = args.length ? args.shift() : {};\n  // Set up options\n  options['numstat'] = true;\n\n  // Check if we have a reference\n  if(reference) {\n    // Execute log function\n    repo.git.log(options, reference, function(err, output) {\n      if(err) return callback(err, output);\n      callback(null, CommitStats.list_from_string(repo, output));\n    });\n  } else {\n    // Add all options\n    options['all'] = true;\n    // Execute log function\n    repo.git.log(options, function(err, output) {\n      if(err) return callback(err, output);\n      callback(null, CommitStats.list_from_string(repo, output));      \n    });\n  }  \n}\n\n// Parse out commit information into an array of baked Commit objects\n//  repo: the repo\n//  text: the text output from the git command (raw format)\n//\n// Returns assoc array of baked commits\nCommitStats.list_from_string = function(repo, text) {\n  var lines = text.trim().split('\\n');\n  var commits = {};\n  \n  while(lines.length > 0) {\n    // Fetch the commit id\n    var id = lines.shift().replace(/\\ +/g, ' ').split(\" \").pop();\n    // Remove some rows\n    lines.shift();\n    lines.shift();\n    lines.shift();\n    \n    // Process message lines\n    var message_lines = [];\n    // Process out the messages\n    while(lines.length > 0 && lines[0].match(/^ {4}/) || lines[0] == '') {\n      var string = lines.shift().substr(4);\n      message_lines.push(string);\n    }\n    \n    // Skip all empty lines\n    while(lines.length > 0 && lines[0] != null && lines[0] == '') lines.shift();\n    \n    var files = [];\n    // Process all the files\n    while(lines.length > 0 && lines[0].match(/^([-\\d]+)\\s+([-\\d]+)\\s+(.+)/)) {\n      var parts = lines.shift().replace(/\\ +/g, ' ').split(\" \");\n      var additions = parseInt(parts[0]);\n      var deletions = parseInt(parts[1]);\n      var filename = parts[2];\n      var total = additions + deletions;\n      files.push([filename, additions, deletions, total]);\n    }\n\n    // Skip all empty lines\n    while(lines.length > 0 && lines[0] != null && lines[0] == '') lines.shift();\n    // Add the commit to the list\n    commits[id] = new CommitStats(repo, id, files);\n  }\n  \n  // Return the commits\n  return commits;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/config.js":"var Config = exports.Config = function(repo) {\n  var _repo = repo, _data = null;\n  \n  Object.defineProperty(this, \"repo\", { get: function() { return _repo; }, set: function(value) { _id = value; }, enumerable: false});    \n  Object.defineProperty(this, \"data\", { get: function() { \n      _data = lazy_reader(_repo, 'data', _data);\n      return _data; \n    }, set: function(value) { _data = value; }, enumerable: true});      \n}\n\nvar lazy_reader = function(repo, name, variable) {\n  if(variable) return variable;\n  // Control the flow\n  var done = false;\n  var hash = {};\n  // Load the config and parse it\n  repo.git.config({list:true}, function(err, output) {\n    var lines = output.split(\"\\n\");\n    \n    lines.forEach(function(line) {\n      var parts = line.split(/=/);\n      var key = parts.shift();\n      hash[key] = parts.join(\"=\");\n    })\n    done = true;\n  })\n\n  while(!done) {};\n  return hash;  \n}\n\nConfig.prototype.fetch = function(key, default_value) {\n  var value = this.data[key];\n  if(!value) return default_value;\n  return this.data[key];\n}\n\nConfig.prototype.set = function(key, value, callback) {\n  var self = this;\n  \n  this.repo.git.config({}, key, value, function(err, output) {\n    if(err) return callback(err, output);\n    // Reset data variable\n    self.data = null;\n    // Return\n    callback(null, output);\n  });\n}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/file_index.js":"var util = require('util'),\n  fs = require('fs');\n\nvar FileIndex = exports.FileIndex = function(repo_path, callback) {\n  var _repo_path = repo_path;\n  var _index_file = repo_path + \"/file-index\";\n  var self = this;  \n  // Set up internal index info\n  var _sha_count = 0, _commit_index = {}, _commit_order = {}, _all_files = {};\n  \n  // Set up properites for instance\n  Object.defineProperty(this, \"repo_path\", { get: function() { return _repo_path; }, enumerable: true});      \n  Object.defineProperty(this, \"index_file\", { get: function() { return _index_file; }, enumerable: true});        \n  // Other values that allow setting\n  Object.defineProperty(this, \"sha_count\", { get: function() { return _sha_count; }, set: function(value) { _sha_count = value; }, enumerable: true});        \n  Object.defineProperty(this, \"commit_index\", { get: function() { return _commit_index; }, set: function(value) { _commit_index = value; }, enumerable: true});        \n  Object.defineProperty(this, \"commit_order\", { get: function() { return _commit_order; }, set: function(value) { _commit_order = value; }, enumerable: true});        \n  Object.defineProperty(this, \"all_files\", { get: function() { return _all_files; }, set: function(value) { _all_files = value; }, enumerable: true});        \n  \n  fs.stat(_index_file, function(err, stat) {\n    if(err) return callback(err, stat);\n    \n    if(stat.isFile() && stat.size < FileIndex.max_file_size) {\n      read_index(self, _index_file, function(err, _index) {\n        if(err) return callback(err, _index);\n        callback(null, _index);\n      })\n    } else {\n      callback(\"index file not found\", null);\n    }\n  });\n}\n\n// Max size for file index\nFileIndex.max_file_size = 10000000;\n\n// Chomp text removing end carriage returns\nvar chomp = function chomp(raw_text) {\n  return raw_text.replace(/(\\n|\\r)+$/, '');\n}\n\nvar dirname = function(file_name) {\n  var elements = file_name.split('/');\n  elements.pop();  \n  if(elements.length == 0) return \".\";\n  return elements.join(\"/\");\n}\n\n// TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO\n// TODO Needs to be async reading files in pieces and parsing them\n// TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO\n// Read and parse the file index for git\nvar read_index = function(file_index, _index_file, callback) {\n  var current_sha = null;\n\n  fs.readFile(_index_file, 'ascii', function(err, data) {\n    if(err) return callback(err, data);\n    // Split the text into lines\n    var lines = data.split(\"\\n\");\n    // Iterate over all the lines\n    for(var i = 0; i < lines.length; i++) {\n      var line = lines[i];  \n      \n      // Ensure it's a line with a starting sha\n      if(line.match(/^(\\w{40})/)) {\n        // Unpack all the sha values (first one being the current_sha and the rest the parents)\n        var shas = line.match(/(\\w{40})/g);\n        current_sha = shas.shift();    \n        // The rest of the sha's are the parents\n        file_index.commit_index[current_sha] = {files:[], parents:shas}\n        file_index.commit_order[current_sha] = file_index.sha_count;\n        file_index.sha_count = file_index.sha_count + 1;\n      } else {\n        var file_name = chomp(line);\n        var tree = '';\n        // Retrieve the directory name for the file passed in\n        var dir = dirname(file_name);\n        // Ensure it's not an empty line        \n        if(line.length > 0) {\n          // Split up the directory\n          var dir_parts = dir.split(\"/\");\n          for(var j = 0; j < dir_parts.length; j++) {\n            var part = dir_parts[j];\n            \n            if(dir_parts[j] != '.') {\n              tree = tree + part + '/'\n              if(file_index.all_files[tree] == null) file_index.all_files[tree]  = [];\n              if(file_index.all_files[tree].indexOf(current_sha) == -1)\n                file_index.all_files[tree].unshift(current_sha);\n            }\n          }\n          \n          // Finish up\n          if(!file_index.all_files[file_name]) file_index.all_files[file_name] = [];\n          file_index.all_files[file_name].unshift(current_sha);\n          file_index.commit_index[current_sha].files.push(file_name);\n        }                \n      }\n    }    \n    // Return the parsed index\n    callback(null, file_index);\n  });  \n}\n\n// Builds a list of all commits reachable from a single commit\nFileIndex.prototype.commits_from = function(commit_sha, callback) {\n  if(Array.isArray(commit_sha)) return callback(\"unsuported reference\", null);\n  // Define some holding structures\n  var already = {};\n  var final = [];\n  var left_to_do = [commit_sha];\n  var self = this;\n  \n  while(left_to_do.length > 0) {\n    commit_sha = left_to_do.shift();\n        \n    if(!already[commit_sha]) {\n      // Add commit to list of final commits\n      final.push(commit_sha);\n      already[commit_sha] = true;\n            \n      // Get parents of the commit and add them to the list\n      var commit = self.commit_index[commit_sha];\n      if(commit) {\n        commit.parents.forEach(function(sha) {\n          left_to_do.push(sha);\n        });        \n      }\n    }\n  }  \n  // Sort the commits\n  final = this.sort_commits(final);\n  // Callback\n  callback(null, final);\n}\n\nFileIndex.prototype.sort_commits = function(sha_array) {\n  var self = this;\n  \n  return sha_array.sort(function(a, b) {\n    return compare(parseInt(self.commit_order[b]), parseInt(self.commit_order[a]));\n  })\n}\n\nvar convert = function(d) {\n  return (\n    d.constructor === Date ? d :\n    d.constructor === Array ? new Date(d[0],d[1],d[2]) :\n    d.constructor === Number ? new Date(d) :\n    d.constructor === String ? new Date(d) :\n    typeof d === \"object\" ? new Date(d.year,d.month,d.date) :\n    NaN\n  );\n}\n\nvar compare = function(a,b) {\n  return (\n    isFinite(a=convert(a).valueOf()) &&\n    isFinite(b=convert(b).valueOf()) ?\n    (a>b)-(a<b) :\n    NaN\n  );\n}\n\n// Returns files changed at commit sha\nFileIndex.prototype.files = function(commit_sha, callback) {\n  if(!this.commit_index[commit_sha]) return callback(\"no files found for sha: \" + commit_sha, null);  \n  callback(null, this.commit_index[commit_sha].files);\n}\n\n// Returns count of all commits\nFileIndex.prototype.count_all = function(callback) {\n  callback(null, this.sha_count);\n}\n\n// returns count of all commits reachable from SHA\nFileIndex.prototype.count = function(commit_sha, callback) {\n  this.commits_from(commit_sha, function(err, commits) {\n    if(err) return callback(err, commits);\n    callback(null, commits.length);\n  })\n}\n\n// returns all commits for a provided file\nFileIndex.prototype.commits_for = function(file, callback) {\n  if(!this.all_files[file]) return callback(\"could not locate any commits for file: \" + file, null);\n  callback(null, this.all_files[file])\n}\n\n// returns the shas of the last commits for all\n// the files in [] from commit_sha\n// files_matcher can be a regexp or an array\nFileIndex.prototype.last_commits = function(commit_sha, files_matcher, callback) {\n  var self = this;\n  \n  this.commits_from(commit_sha, function(err, acceptable) {\n    if(err) return callback(err, acceptable);    \n    var matches = {};\n    \n    if(files_matcher.constructor == RegExp) {\n      // Filter all the files by the matching regular expression\n      files_matcher = Object.keys(self.all_files).filter(function(file) {        \n        return file.match(files_matcher);\n      });\n    }\n    \n    if(Array.isArray(files_matcher)) {\n      // Locate the last commit for each file in the files_matcher array\n      for(var files_matcher_index = 0; files_matcher_index < files_matcher.length; files_matcher_index++) {\n        var files = self.all_files[files_matcher[files_matcher_index]];\n        \n        for(var files_index = 0; files_index < files.length; files_index++) {\n          // If the file is included in the list of commits_from then add it to the matches\n          if(acceptable.indexOf(files[files_index]) != -1) {\n            matches[files_matcher[files_matcher_index]] = files[files_index];\n            break;\n          }          \n        }\n      }\n    }\n    \n    // Return matches\n    callback(null, matches);\n  });\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/file_window.js":"var util = require('util'),\n  fs = require('fs'),\n  Buffer = require('buffer').Buffer;\n\nvar FileWindow = exports.FileWindow = function(idxfile, version) {\n  var _idxfile = idxfile, _version = version, _global_offset, _offset = null, _seek_offset = 0;\n  // Set file global offset\n  _global_offset = _version == 2 ? 8 : 0;\n  //Internal properties\n  Object.defineProperty(this, \"idxfile\", { get: function() { return _idxfile; }, set: function(value) { _idxfile = value; }, enumerable: true});\n  Object.defineProperty(this, \"version\", { get: function() { return _version; }, enumerable: true});\n  Object.defineProperty(this, \"global_offset\", { get: function() { return _global_offset; }, enumerable: true});\n  Object.defineProperty(this, \"offset\", { get: function() { return _offset; }, set: function(value) { _offset = value; }, enumerable: true});\n  Object.defineProperty(this, \"seek_offset\", { get: function() { return _seek_offset; }, set: function(value) { _seek_offset = value; }, enumerable: true});\n}\n\nFileWindow.prototype.unmap = function() {\n  this.idxfile = null;\n}\n\nFileWindow.prototype.index = function(idx) {\n  var offset = null, len = null, seek_offset = null;\n  // open the file\n  var idx_handle = fs.openSync(this.idxfile, \"r\");\n  \n  if(idx.length == 1) idx = idx[0];\n  // Number support\n  if(idx.constructor == Number && idx === parseInt(value, 10)) {\n    offset = idx;\n    len = null;\n  } else if(Array.isArray(idx)) {\n    offset = idx[0];\n    len = idx[1]\n  } else {\n    throw \"invalid index param: \" + util.inspect(idx);\n  }\n  \n  // Seek position equivalent using a position in the read\n  if(this.offset != offset) {\n    this.seek_offset = offset + this.global_offset;\n  }\n  \n  // Adjust the stored offset\n  this.offset = (offset + len) ? len : 1;  \n  if(!len) len = 1;    \n\n  // Read the offset value\n  var buffer = new Buffer(len);\n    \n  if(len) {\n    fs.readSync(idx_handle, buffer, 0, len, this.seek_offset);\n  } else {\n    fs.readSync(idx_handle, buffer, 0, 1, this.seek_offset);    \n  }\n  // Update seek_offset\n  this.seek_offset = this.seek_offset + len;\n  \n  // Close the file don't keep file handles around\n  fs.closeSync(idx_handle);\n  return buffer;\n} \n\nFileWindow.prototype.close = function() {\n  // fs.closeSync(this.idxfile);\n  this.unmap();\n}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/git.js":"var util = require('util'),\n    fs = require('fs'),\n    GitFileOperations = require('./git_file_operations').GitFileOperations,\n    exec = require('child_process').exec,\n    FileIndex = require('./file_index').FileIndex,\n    Repository = require('./repository').Repository,\n    Difference = require('../diff/diff').Difference;\n\nvar Git = exports.Git = function(git_directory) {\n  var _git_diretory = git_directory, _git_file_index;\n  var _repository = new Repository(_git_diretory, {});\n  // Control access to internal variables\n  Object.defineProperty(this, \"git_directory\", { get: function() { return _git_diretory; }, set: function(value) { _git_diretory = value; }, enumerable: true});\n  Object.defineProperty(this, \"git_file_index\", { get: function() { return _git_file_index; }, set: function(value) { _git_file_index = value; }, enumerable: true});\n  Object.defineProperty(this, \"repository\", { get: function() { return _repository; }, set: function(value) { _repository = value; }, enumerable: true});\n}\n\n// Set up the gitbinary\nif(process.platform.toLowerCase().match(/mswin(?!ce)|mingw|bccwin|win32/)) {\n  Git.git_binary = \"git\";\n} else {\n  Git.git_binary = \"/usr/bin/env git\";\n}\n\n// Chomp text removing end carriage returns\nvar chomp = function chomp(raw_text) {\n  return raw_text ? raw_text.replace(/(\\n|\\r)+$/, '') : '';\n}\n\nvar read_file = function(path, callback) {\n  fs.stat(path, function(err, stat) {\n    if(err) return callback(err, null);\n    fs.readFile(path, 'ascii', callback);\n  })\n}\n\n// Retrieve references\nGit.prototype.refs = function(options, prefix, callback) {\n  var refs = [];\n  var already = {};\n  var self = this;\n\n  // Locate all files in underlying directories\n  var stream = GitFileOperations.glob_streaming(this.git_directory + \"/\" + prefix);\n  // Triggers on each entry in the directory\n  stream.addListener(\"data\", function(result) {\n    // If we have a directory check if we have a reference file\n    if(result.stat.isFile()) {\n      // Read the file content\n      try {\n        var id = chomp(fs.readFileSync(result.path, 'ascii'));\n        var name = result.path.replace(self.git_directory + \"/\" + prefix + \"/\", '');\n\n        if(!already[name]) {\n          refs.push(name + \" \" + id);\n          already[name] = true;\n        }\n      } catch(err) {\n        // Seems to be some instances where it's not able to tell that a directory is not a file ?\n      }\n    }\n  });\n\n  // Triggers at the end of the call\n  stream.addListener(\"end\", function(err, result) {\n    fs.stat(self.git_directory + \"/packed-refs\", function(err, stat) {\n      if(err || !stat.isFile()) return callback(null, refs.join(\"\\n\"));\n\n      read_file(self.git_directory + \"/packed-refs\", function(err, data) {\n        var parts = data.split(/\\n/);\n        // Scan all lines\n        for(var i = 0; i < parts.length; i++) {\n          var match = parts[i].match(/^(\\w{40}) (.*?)$/)\n          if(match) {\n            if(match[2].match(\"^\" + prefix)) {\n              var id = chomp(match[1]);\n              var name = match[2].replace(prefix + \"/\", '');\n\n              if(!already[name]) {\n                refs.push(name + \" \" + id);\n                already[name] = true;\n              }\n            }\n          }\n        }\n        // Return all the references\n        callback(null, refs.join(\"\\n\"));\n      });\n    })\n  })\n}\n\n// Read a specific file\nGit.prototype.fs_read = function(file, callback) {\n  GitFileOperations.fs_read(this.git_directory, file, callback);\n}\n\n// // Parse revisions\n// Git.prototype.rev_parse = function(options, string, callback) {\n//  if(string == null || string.constructor != String) return callback(\"invalid string: \" + string);\n//  var self = this;\n//\n//  // Make sure we don't have a directory up ..\n//  if(string.match(/\\.\\./)) {\n//    var shas = string.split(/\\.\\./);\n//    var sha1 = shas[0], sha2 = shas[1];\n//    // Need to rev_parse the two keys and return the data\n//    new Simplifier().execute(new ParallelFlow(\n//       function(callback) { self.rev_parse({}, sha1, callback); },\n//       function(callback) { self.rev_parse({}, sha2, callback); }\n//      ), function(sha1_results, sha2_results) {\n//      // Return the collected files\n//      return callback(null, [sha1_results[1], sha2_results[1]]);\n//    });\n//  }\n//\n//  // If we have a sha being returned nop it\n//  if(string.match(/^[0-9a-f]{40}$/)) {\n//    return callback(null, chomp(string));\n//  }\n//\n//  // Check in heads directory\n//  read_file(self.git_directory + \"/refs/heads/\" + string, function(err, data) {\n//    if(!err) return fs.readFile(self.git_directory + \"/refs/heads/\" + string, function(err, data) { callback(err, chomp(data)); });\n//    // If not in heads then check in remotes\n//    read_file(self.git_directory + \"/refs/remotes/\" + string, function(err, data) {\n//      if(!err) return fs.readFile(self.git_directory + \"/refs/remotes/\" + string, function(err, data) { callback(err, chomp(data)); });\n//      // If not in remotes check in tags\n//      read_file(self.git_directory + \"/refs/tags/\" + string, function(err, data) {\n//        if(!err) return fs.readFile(self.git_directory + \"/refs/tags/\" + string, function(err, data) { callback(err, chomp(data)); });\n//\n//        // Not pin any of the main refs, look in packed packed-refs\n//        read_file(self.git_directory + \"/packed-refs\", function(err, data) {\n//          if(err) return callback(err, data);\n//          // Split the data on new line\n//          var ref = null;\n//          var parts = data.split(/\\n/);\n//          // Locate head\n//          for(var i = 0; i < parts.length; i++) {\n//            var match_parts = parts[i].match(/^(\\w{40}) refs\\/.+?\\/(.*?)$/);\n//            if(match_parts) {\n//              ref = match_parts[1];\n//              // If we have a match fetch reference and return\n//              if(new RegExp(string + '$').test(match_parts[3])) {\n//                break;\n//              }\n//            }\n//          }\n//\n//          // If we have a reference lets terminate\n//          if(ref) return callback(null, ref);\n//\n//          // !! more partials and such !!\n//\n//\n//          // revert to calling git\n//          self.call_git('', 'rev-parse', '', options, string, function(err, result) {\n//            result = result ? chomp(result) : result;\n//            callback(err, result);\n//          })\n//        });\n//      });\n//    });\n//  });\n// }\n\nGit.prototype.transform_options = function(options) {\n  var args = [];\n  var keys = Object.keys(options);\n\n  // Process all entries\n  Object.keys(options).forEach(function(key) {\n    if(key.length == 1) {\n      if(options[key] == true && options[key].constructor == Boolean) { args.push('-' + key);\n      } else if(options[key] == false && options[key].constructor == Boolean) {\n      } else { args.push('-' + key + ' \"' + options[key].toString().replace('\"', \"\\\\\\\"\") + '\"'); }\n    } else {\n      if(options[key] == true && options[key].constructor == Boolean) { args.push(\"--\" + key.toString().replace(/_/, '-'));\n      } else if(options[key] == false && options[key].constructor == Boolean) {\n      } else { args.push('--' + key.toString().replace(/_/, '-') + '=\"' + options[key].toString().replace('\"', \"\\\\\\\"\") + '\"'); }\n    }\n  });\n\n  // Return formated parametes\n  return args;\n}\n\nGit.prototype.git = function() {\n  // Unpack parameters as commit might be null\n  var args = Array.prototype.slice.call(arguments, 0);\n  var callback = args.pop();\n  // Unpack the variables\n  var function_name = args.length ? args.shift() : null;\n  var options = args.length ? args.shift() : {};\n  var arguments = args;\n  // Execute blame command\n  this.call_git('', function_name, '', options, arguments, function(err, result) {\n    callback(err, result);\n  });\n}\n\nvar shell_escape = function(str) {\n  return str.toString().replace('\"', \"\\\\\\\"\").replace(/\\;/g, \"\\\\;\");\n}\n\n// Call the native git binary\nGit.prototype.call_git = function(prefix, command, postfix, options, args, callback) {\n  // Do we have a timeout\n  var timeout = options['timeout'] ? timeout : 1000 * 60;\n  var call_string = '';\n  // Remove the timeout property if we have one\n  if(options['timeout']) delete options['timeout'];\n  var option_arguments = this.transform_options(options);\n\n  if(process.platform.toLowerCase().match(/mswin(?!ce)|mingw|bccwin/)) {\n  } else {\n    // Map the extra parameters\n    var ext_args = args.map(function(arg) { return (arg == '--' || arg.substr(0, 1) == '|' ? arg : ('\"' + shell_escape(arg) + '\"'))})\n                    .filter(function(arg) { return arg == null || arg == '' ? false : true});\n    // Join the arguments\n    var final_arguments = option_arguments.concat(ext_args);\n    // Build a call\n    call_string = prefix + Git.git_binary + ' --git-dir=\"'+ this.git_directory + '\" ' + command.toString().replace(/_/, '-') + ' ' + final_arguments.join(\" \") + postfix;\n  }\n  // Execute the function\n  execute_git_call(call_string, { encoding: 'utf8', timeout: timeout, killSignal: 'SIGKILL'}, callback);\n}\n\nvar execute_git_call = function(call_string, options, callback) {\n  // Execute the git command\n  options.maxBuffer = 1024 * 1024;\n  exec(call_string, options,\n    function (error, stdout, stderr) {\n      if (error != null) {\n        var result = error.toString();\n        callback(result != null ? result.trim() : result, null);\n      } else {\n        var result = stdout.toString();\n        callback(null, result != null ? result.trim() : result)\n      }\n  });\n}\n\nvar file_index = function(git, callback) {\n  // If we have a file index object return it otherwise create a new one\n  if(!git.git_file_index) {\n    new FileIndex(git.git_directory, function(err, _file_index) {\n      git.git_file_index = _file_index;\n      callback(null, _file_index);\n    });\n  } else {\n    callback(null, git.git_file_index);\n  }\n}\n\n// Fetch a revision list\nGit.prototype.rev_list = function(options, reference, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 0);\n  var callback = args.pop();\n  options = args.length ? args.shift() : {};\n  reference = args.length ? args.shift() : 'master';\n\n  // Remove skip option if it's set to 0\n  if(options['skip'] != null && parseInt(options['skip']) == 0) delete options['skip'];\n  var allowed_options = {\"max_count\":1, \"since\":1, \"until\":1, \"pretty\":1};\n  var establish_keys = Object.keys(options).filter(function(key) {\n      return allowed_options[key] ? false : true;\n    });\n\n  // If we have commands we don't support call through to native git\n  if(establish_keys.length > 0) {\n    self.call_git('', 'rev_list', '', options, [reference], function(err, result) {\n      callback(err, result);\n    })\n  } else if(Object.keys(options).length == 0){\n    // Fetch the file index (will create a file index on the first call)\n    file_index(self, function(err, _file_index) {\n      if(err) return callback(err, _file_index);\n      // Parse the revision\n      self.rev_parse({}, reference, 0, function(err, ref) {\n        if(err) return callback(err, ref);\n        // Fetch the commits from the revision passed in\n        _file_index.commits_from(ref, function(err, commits) {\n          if(err) {\n            self.call_git('', 'rev_list', '', options, [reference], function(err, result) {\n              callback(err, result);\n            })\n          } else {\n            callback(null, commits.join(\"\\n\") + \"\\n\");\n          }\n        })\n      });\n    })\n  } else {\n    self.rev_parse({}, reference, 0, function(err, ref) {\n      if(err) return callback(err, ref);\n\n      if(Array.isArray(ref)) {\n        self.call_git('', 'rev_list', '', options, [reference], function(err, result) {\n          callback(err, result);\n        })\n      } else {\n        try {\n          // Try to execute revision fetch\n          self.repository.rev_list(ref, options, function(err, result) {\n            callback(err, result);\n          })\n        } catch(err) {\n          callback(err, null);\n        }\n      }\n    });\n  }\n}\n\n// Chomp text removing end carriage returns\nvar chomp = function chomp(raw_text) {\n  return raw_text.replace(/(\\n|\\r)+$/, '');\n}\n\nGit.prototype.rev_parse = function(options, string, level, callback) {\n  if(string != null && string.constructor != String) return callback('only supports single sha reference');\n  var self = this;\n\n  // Allow leaving of level\n  var args = Array.prototype.slice.call(arguments, 2);\n  var callback = args.pop();\n  level = args.length ? args.shift() : 0;\n\n  if(string.match(/\\.\\./)) {\n    var parts = string.split(\"..\");\n    var sha1 = parts[0], sha2 = parts[1];\n    var value = [this.rev_parse({}, sha1, level + 1, callback), this.rev_parse({}, sha2, level + 1, callback)];\n    if(level == 0) return callback(null, value);\n  }\n\n  // a sha is being passed in, chomp and return\n  if(string.match(/^[0-9a-f]{40}$/)) {\n    var value = chomp(string);\n    if(level == 0) {\n      return callback(null, value);\n    } else {\n      return value;\n    }\n  }\n\n  // Check all the references\n  var head = this.git_directory + \"/refs/heads/\" + string;\n  try {\n    if(level == 0) {\n      return callback(null, chomp(fs.readFileSync(head, 'utf8')));\n    } else {\n      return chomp(fs.readFileSync(head, 'utf8'));\n    }\n  } catch(err) {}\n\n  var head = this.git_directory + \"/refs/remotes/\" + string;\n  try {\n    if(level == 0) {\n      return callback(null, chomp(fs.readFileSync(head, 'utf8')));\n    } else {\n      return chomp(fs.readFileSync(head, 'utf8'));\n    }\n  } catch(err) {}\n\n  var head = this.git_directory + \"/refs/tags/\" + string;\n  try {\n    if(level == 0) {\n      return callback(null, chomp(fs.readFileSync(head, 'utf8')));\n    } else {\n      return chomp(fs.readFileSync(head, 'utf8'));\n    }\n  } catch(err) {}\n\n  // Check packed-refs file, too\n  var packref = this.git_directory + \"/packed-refs\";\n  try {\n    // Read the file\n    var parts = data.split(/\\n/);\n    // Locate head\n    for(var i = 0; i < parts.length; i++) {\n     var match_parts = parts[i].match(/^(\\w{40}) refs\\/.+?\\/(.*?)$/);\n     if(match_parts) {\n       ref = match_parts[1];\n       // If we have a match fetch reference and return\n       if(new RegExp(string + '$').test(match_parts[3])) {\n         if(level == 0) {\n           return callback(null, chomp(ref));\n         } else {\n           return chomp(ref);\n         }\n       }\n     }\n    }\n  } catch(err) {}\n\n  // Wait until we got the git call\n  self.call_git('', 'rev-parse', '', options, [string], function(err, result) {\n    callback(null, result ? chomp(result) : result);\n  })\n}\n\n// List tree content\nGit.prototype.ls_tree = function(treeish, paths, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1);\n  var callback = args.pop();\n  paths = args.length ? args.shift() : [];\n  paths = paths ? paths : [];\n  options = args.length ? args.shift() : {};\n\n  try {\n    // Reverse parse the tree sha\n    this.rev_parse({}, treeish, function(err, sha) {\n      if(err) return callback(err, sha);\n      var tree = self.repository.ls_tree(sha, flatten(paths), options['r']);\n      if(tree == '') return callback('no such sha found', null);\n      // Ls_tree\n      callback(null, tree);\n    })\n  } catch(err) {\n    callback(err, null);\n  }\n}\n\n// Cat a file\nGit.prototype.cat_file = function(type, ref, callback) {\n  if(type == \"t\") {\n    this.file_type(ref, callback);\n  } else if(type == \"s\") {\n    this.file_size(ref, callback);\n  } else if(type == \"p\") {\n    callback(null, this.repository.cat_file(ref));\n  }\n}\n\nGit.prototype.file_size = function(ref, callback) {\n  callback(null, this.repository.cat_file_size(ref));\n}\n\n// Make a directory\n//  dir: is the relative path to the directory to create\n//\n// Return nothing\nGit.prototype.fs_mkdir = function(dir, callback) {\n  var path = this.git_directory + \"/\" + dir;\n  GitFileOperations.fs_mkdir(path, callback);\n}\n\n// Initialize a new git repository (create physical setup)\nGit.prototype.init = function(options, callback) {\n  var self = this;\n  var arguments = Array.prototype.slice(arguments);\n\n  if(Object.keys(options).length == 0) {\n    Repository.init(this.git_directory, callback);\n  } else {\n    // Execute init with call git and return the object\n    this.call_git('', 'init', '', options, arguments, function(err, result) {\n      if(err) return callback(err, result);\n      callback(null, self);\n    });\n  }\n}\n\n// Clone a directory\nGit.prototype.clone = function(options, original_path, target_path, callback) {\n}\n\n// Generate diff from the changes between two shas\n// Git.prototype.diff = function(options, sha1, sha2, callback) {\n// }\n//\n// var simple_diff = function(repo, options, sha1, sha2, callback) {\n//\n// }\n//\n// var native_diff = function(repo, options, sha1, sha2, base, paths, callback) {\n//\n// }\n\n// Gotten from\nvar flatten = function(array) {\n  return array.reduce(function(a,b) {\n    return a.concat(b);\n  }, []);\n}\n\nGit.prototype.diff = function(commit1, commit2, options, callback) {\n  try {\n    var self = this;\n    var args = Array.prototype.slice.call(arguments, 2);\n    // Pop the callback\n    var callback = args.pop();\n    options = args.length ? args.shift() : {};\n\n    // Initialize patch variable\n    var patch = '', commit_obj1 = null, tree1 = null, tree2 = null;\n    // Retrieve the first commit object\n    var commit_obj1 = self.repository.get_object_by_sha1(commit1);\n    var tree1 = commit_obj1.tree;\n\n    if(commit2) {\n      tree2 = self.repository.get_object_by_sha1(commit2).tree;\n    } else {\n      tree2 = self.repository.get_object_by_sha1(commit_obj1.parent[0]).tree;\n    }\n\n    var qdiff = self.repository.quick_diff(tree1, tree2).sort();\n    qdiff.forEach(function(diff_arr) {\n      // Set up all the variables\n      var path = diff_arr[0];\n      var status = diff_arr[1];\n      var treeSHA1 = diff_arr[2];\n      var treeSHA2 = diff_arr[3];\n      var format = 'unified';\n      var lines = 3;\n      var output = '';\n      var file_length_difference = 0;\n\n      // Fetch the files\n      var fileA = treeSHA1 ? self.repository.cat_file(treeSHA1) : '';\n      var fileB = treeSHA2 ? self.repository.cat_file(treeSHA2) : '';\n\n      // Get the sha's or set empty shas\n      var sha1 = treeSHA1 || '0000000000000000000000000000000000000000';\n      var sha2 = treeSHA2 || '0000000000000000000000000000000000000000';\n\n      // Split up data\n      var data_old = fileA.trim().split(/\\n/).map(function(e) { return chomp(e); });\n      var data_new = fileB.trim().split(/\\n/).map(function(e) { return chomp(e); });\n      // Javascript split's a file into [''] if it's an empty file\n      if(data_old.length == 1 && data_old[0] == '') data_old = [];\n      if(data_new.length == 1 && data_new[0] == '') data_new = [];\n\n      // Get diffs\n      var diffs = Difference.LCS.diff(data_old, data_new);\n      if(diffs.length > 0) {\n        // Create paths\n        var a_path = \"a/\" + path.replace(/\\.\\//g, '');\n        var b_path = \"b/\" + path.replace(/\\.\\//g, '');\n        // Let's create the header\n        var header = \"diff --git \" + a_path + \" \" + b_path;\n        if(options['full_index']) {\n          header = header + '\\n' + 'index ' + sha1 + '..' + sha2;\n          if(treeSHA2) header = header + \"' 100644\";\n        } else {\n          header = header + '\\n' + 'index ' + sha1.substr(0, 7) + '..' + sha2.substr(0, 7);\n          if(treeSHA2) header = header + ' 100644';\n        }\n\n        header = header + '\\n--- ' + (treeSHA1 ? a_path : '/dev/null');\n        header = header + '\\n+++ ' + (treeSHA2 ? b_path : '/dev/null');\n        header = header + '\\n';\n\n        // standard hunk\n        var old_hunk = null, hunk = null;\n        // Process all the diff changes\n        diffs.forEach(function(piece) {\n\n          try {\n            hunk = new Difference.LCS.Hunk(data_old, data_new, piece, lines, file_length_difference);\n            file_length_difference = hunk.file_length_difference;\n\n            if(old_hunk) {\n              if(lines > 0 && hunk.overlaps(old_hunk)) {\n                hunk.unshift(old_hunk);\n              } else {\n                output = output + old_hunk.diff(format);\n              }\n            }\n          } catch(err) {}\n\n          old_hunk = hunk;\n          output = output + '\\n';\n        });\n\n        // Prepare next\n        output = output + old_hunk.diff(format);\n        output = output + '\\n';\n        patch = patch + header + output.trimLeft();\n      }\n    });\n\n    // Return the patch\n    callback(null, patch);\n  } catch(err) {\n    callback('tree was bad or lcs is not working', null);\n  }\n}\n\n// Check if a file exists\nGit.prototype.fs_exist = function(path, callback) {\n  GitFileOperations.fs_exist(this.git_directory, path, callback);\n}\n\n// Write a normal file to the filesystem\n//  file: relative path from the Git dir\n//  contents: String content to be written\n//\n// Return nothing\nGit.prototype.fs_write = function(file, content, callback) {\n  GitFileOperations.fs_write(this.git_directory, file, content, callback);\n}\n\n// Log function, returns the number of logs\nGit.prototype.log = function(commit, path, options, callback) {\n  args = ['--raw', '--no-abbrev', '--numstat'];\n  if (path) {\n    args.push('--');\n    args.push(path);\n  }\n  options.color = 'never';\n  this.call_git('', 'log', '', options, args, callback);\n}\n\n// Select the objects that exists\n//  object_ids: array of object sha's\n//\n// Returns array of ids's that exist\nGit.prototype.select_existing_objects = function(object_ids, callback) {\n  var existing_object_ids = [];\n  // Process all the object ids\n  for(var i = 0; i < object_ids.length; i++) {\n    // Check if the object_id exists in the db\n    this.repository.object_exists(object_ids[i], function(err, result)  {\n      if(err) return callback(err, result);\n      if(result) existing_object_ids.push(object_ids[i]);\n    });\n  }\n  // Return all the existing objects\n  callback(null, existing_object_ids);\n}\n\n// Format the patch\nGit.prototype.format_patch = function(options, reference, callback) {\n  this.call_git('', 'format_patch', '', options, [reference], function(err, result) {\n    callback(err, result);\n  })\n}\n\n// Fetch the blame\nGit.prototype.blame = function() {\n  // Unpack parameters as commit might be null\n  var args = Array.prototype.slice.call(arguments, 0);\n  var callback = args.pop();\n  var options = args.length ? args.shift() : {};\n  var arguments = args;\n\n  // Execute blame command\n  this.call_git('', 'blame', '', options, arguments, function(err, result) {\n    callback(err, result);\n  });\n}\n\nvar clean_paths = function(commits) {\n  var new_commits = {};\n  // Iterate over all the commit hash entries and clean the directory names\n  Object.keys(commits).forEach(function(file) {\n    var sha = commits[file];\n    file = file.substr(file.length - 1, 1) == '/' ? file.substr(0, file.length - 1) : file;\n    new_commits[file] = sha;\n  })\n  // Return all the cleaned commits\n  return new_commits;\n}\n\n// Fetch blame tree\nGit.prototype.blame_tree = function(commit, path, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1);\n  var callback = args.pop();\n  path = args.length ? args.shift() : null;\n\n  // Create path\n  path = path != null && path != '' ? [path].join(\"/\").toString() + '/' : path;\n  path = !path || path.constructor != String ? '' : path;\n\n  // Fetch the file_index\n  file_index(this, function(err, file_index_instance) {\n    if(err) return callback(err, file_index_instance);\n\n    self.rev_parse({}, commit, 0, function(err, rev_parse_output) {\n      if(err) return callback(err, rev_parse_output);\n\n      self.looking_for(commit, path, function(err, looking_for) {\n        if(err) return callback(err, looking_for);\n\n        file_index_instance.last_commits(rev_parse_output, looking_for, function(err, commits) {\n          if(err) return callback(err, commits);\n\n          callback(null, clean_paths(commits));\n        });\n      });\n    });\n  });\n}\n\n// Looking for\nGit.prototype.looking_for = function(commit, path, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1);\n  var callback = args.pop();\n  path = args.length ? args.shift() : null;\n  var file = null;\n\n  // Fetch the commit sha\n  self.rev_parse({}, commit, 0, function(err, rev_parse_output) {\n    if(err) return callback(err, rev_parse_output);\n\n    // Fetch the sub tree\n    self.repository.get_subtree(rev_parse_output, path, function(err, tree_sha) {\n      if(err) return callback(err, tree_sha);\n\n      // Contains the files\n      var looking_for = [];\n      // Fetch and return the object by the tree sha\n      var object = self.repository.get_object_by_sha1(tree_sha);\n      // Process all the entries for the object\n      object.entries.forEach(function(entry) {\n        file = path && !(path == '' || path == '.' || path == './') ?  path + \"/\" + entry.name : entry.name;\n        // Ensure no double path characters\n        file = file.replace('//', '/');\n        // Add a slash if it's a directory\n        if(entry.type == 'directory') file = file + \"/\";\n        // Add to list of looking_for entries\n        looking_for.push(file);\n      });\n\n      // Return the entries\n      return callback(null, looking_for);\n    });\n  });\n}\n\n// Peform commit\nGit.prototype.commit = function() {\n  // Unpack parameters as commit might be null\n  var args = Array.prototype.slice.call(arguments, 0);\n  var callback = args.pop();\n  var options = args.length ? args.shift() : {};\n  var arguments = args;\n\n  // Execute blame command\n  this.call_git('', 'commit', '', options, arguments, function(err, result) {\n    callback(err, result);\n  });\n}\n\n// Fetch config\nGit.prototype.config = function() {\n  // Unpack parameters as commit might be null\n  var args = Array.prototype.slice.call(arguments, 0);\n  var callback = args.pop();\n  var options = args.length ? args.shift() : {};\n  var arguments = args;\n  // Execute blame command\n  this.call_git('', 'config', '', options, arguments, function(err, result) {\n    callback(err, result);\n  });\n}\n\n// Execute add command\nGit.prototype.add = function() {\n  // Unpack parameters as commit might be null\n  var args = Array.prototype.slice.call(arguments, 0);\n  var callback = args.pop();\n  var options = args.length ? args.shift() : {};\n  var arguments = args;\n  // Execute blame command\n  this.call_git('', 'add', '', options, arguments, function(err, result) {\n    callback(err, result);\n  });\n}\n\n// Execute remove command\nGit.prototype.remove = function() {\n  // Unpack parameters as commit might be null\n  var args = Array.prototype.slice.call(arguments, 0);\n  var callback = args.pop();\n  var options = args.length ? args.shift() : {};\n  var arguments = args;\n  // Execute blame command\n  this.call_git('', 'rm', '', options, arguments, function(err, result) {\n    callback(err, result);\n  });\n}\n\n// Execute ls-files\nGit.prototype.ls_files = function() {\n  // Unpack parameters as commit might be null\n  var args = Array.prototype.slice.call(arguments, 0);\n  var callback = args.pop();\n  var options = args.length ? args.shift() : {};\n  var arguments = args;\n  // Execute blame command\n  this.call_git('', 'ls-files', '', options, arguments, function(err, result) {\n    callback(err, result);\n  });\n}\n\n// Execute diff-files\nGit.prototype.diff_files = function() {\n  // Unpack parameters as commit might be null\n  var args = Array.prototype.slice.call(arguments, 0);\n  var callback = args.pop();\n  var options = args.length ? args.shift() : {};\n  var arguments = args;\n  // Execute blame command\n  this.call_git('', 'diff-files', '', options, arguments, function(err, result) {\n    callback(err, result);\n  });\n}\n\n// Execute diff-index\nGit.prototype.diff_index = function() {\n  // Unpack parameters as commit might be null\n  var args = Array.prototype.slice.call(arguments, 0);\n  var callback = args.pop();\n  var options = args.length ? args.shift() : {};\n  var arguments = args;\n  // Execute blame command\n  this.call_git('', 'diff-index', '', options, arguments, function(err, result) {\n    callback(err, result);\n  });\n}\n\nGit.prototype.file_type = function(ref, callback) {\n  return callback(null, this.repository.cat_file_type(ref));\n}\n\nGit.prototype.put_raw_object = function(content, type, callback) {\n  return this.repository.put_raw_object(content, type, callback);\n}\n\nGit.prototype.commit_from_sha = function(id) {\n  var repository = new Repository(this.git_directory);\n  var object = repository.get_object_by_sha1(id);\n\n  if(object.type == \"commit\") {\n    return id;\n  } else if(object.type == \"tag\") {\n    return object.object;\n  } else {\n    return '';\n  }\n}\n\n\n// // ===================================================================================================\n// //\n// //  Decorates the Class prototype with functions wrapping git native functions (if not defined already)\n// //\n// // ===================================================================================================\n// Git.prototype.call_git('', 'help', '', {}, ['--all'], function(err, result) {\n//   var index = result.indexOf(\"-----------\");\n//   result = result.substr(index);\n//   var lines = result.trim().split(\"\\n\");\n//   // Ship the first line\n//   lines.shift();\n//   // Process all the lines\n//   while(lines.length > 0 && lines[0] != '') {\n//     var line = lines.shift().trim().replace(/ +/g, ' ');\n//     var parts = line.split(\" \");\n//\n//     parts.forEach(function(command) {\n//       var function_name = command.replace(/\\-/g, '_');\n//       // For each entry create a new function if it does not exist on the prototype\n//       if(Git.prototype[function_name] == null) {\n//         Git.prototype[function_name] = function() {\n//           // Unpack parameters as commit might be null\n//           var args = Array.prototype.slice.call(arguments, 0);\n//           callback = args.pop();\n//           var options = args.length ? args.shift() : {};\n//           var arguments = args;\n//           // Execute blame command\n//           this.call_git('', command, '', options, arguments, function(err, result) {\n//             callback(err, result);\n//           });\n//         }\n//       }\n//     });\n//\n//   }\n//\n//   // callback(null, null);\n//   pre_loading_done = true\n//   // var g = new Git(\"..../\")\n// });\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/git_file_operations.js":"var util = require('util'),\n  fs = require('fs'),\n  exec  = require('child_process').exec;\n\nvar GitFileOperations = exports.GitFileOperations = function() {}\n\n// Streaming glob function\nvar streaming_glob_function = function(path, stream) {\n  var entries = fs.readdirSync(path);\n  entries.forEach(function(entry) {\n    var entry_path = path + \"/\" + entry;    \n    var stat = fs.statSync(entry_path);\n    \n    if(stat.isDirectory()) {\n      stream.emit(\"data\", {path:entry_path, stat:stat});\n      streaming_glob_function(entry_path, stream);\n    } else {\n      stream.emit(\"data\", {path:entry_path, stat:stat});\n    }\n  })\n}\n\nvar stat_with_entry = function(entry_path, stream, callback) {\n  return function() {\n    fs.stat(entry_path, function(err, stat) {\n      if(stat.isDirectory()) {\n        // Dive into the directory\n        streaming_glob_function(entry_path, stream);\n        // Emit the directory and then update the count\n        stream.emit(\"data\", {path:entry_path, stat:stat});\n        callback();\n      } else if(stat.isFile()) {\n        // Update the number of processed directories and emit the data event\n        stream.emit(\"data\", {path:entry_path, stat:stat});\n        callback();\n      }\n    });    \n  }\n}\n\n// Glob function for the file system\nGitFileOperations.glob_streaming  = function(path) {\n  // Comptability\n  var nextTick = global.setImmediate || process.nextTick;\n  // Create a stream object\n  var stream = new process.EventEmitter();\n  var processed_directories_count = 0;\n  var top_level_files_count = -1;\n  // Tick method\n  var tick_function = function() {\n    // If we are done emit end otherwise execute the method again\n    processed_directories_count == top_level_files_count ? stream.emit(\"end\") : nextTick(tick_function);\n  }\n  // set nextTick handler into action\n  nextTick(tick_function);\n  // Fetch the top directory\n  fs.readdir(path, function(err, entries) {\n    // The top level of files that need to be finished processing for us to be done\n    if(entries !== undefined && entries.length > 0)  {\n      entries.sort(function(a, b) {\n          return a > b;\n      });\n\n      top_level_files_count = entries.length;\n      // Execute the entries\n      var procesEntry = function(i) {\n        // Entry path\n        var entry_path = path + \"/\" + entries[i];\n        // Build glob function\n        stat_with_entry(entry_path, stream, function() {\n          processed_directories_count = processed_directories_count + 1;\n          if (++i < entries.length) {\n            procesEntry(i);\n          }\n        })();\n      };\n      procesEntry(0);\n    } else {\n      top_level_files_count = 0;\n    }\n  });  \n  // Return the stream for execution\n  return stream;\n}\n\n// Execute recursive glob function (private function)\nvar glob_function = function(path, files) {\n  var entries = fs.readdirSync(path);\n  entries.forEach(function(entry) {\n    var entry_path = path + \"/\" + entry;\n    \n    var stat = fs.statSync(entry_path);\n    if(stat.isDirectory()) {\n      glob_function(entry_path, files);\n    } else {\n      files.push(entry_path);\n    }\n  })\n}\n\n// Glob function for the file system\nGitFileOperations.glob = function(path, files, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  files = args.length ? args.shift() : [];\n  // Fetch all the files\n  glob_function(path, files);\n  callback(null, files);\n}\n\n// Read a file\nGitFileOperations.fs_read = function(path, file, callback) {\n  fs.readFile(path + \"/\" + file, callback);\n} \n\n// Make a directory\nGitFileOperations.fs_mkdir = function(dir, callback) {\n  fs.mkdir(dir, 16877, callback);\n}\n\n// Check if a directory exists\nGitFileOperations.fs_exist = function(dir, path, callback) {\n}\n\n// Delete directory\nGitFileOperations.fs_rmdir_r = function(dir, callback) {\n  // Copy the old directory to the new one\n  var child = exec('rm -rf ' + dir, function (error, stdout, stderr) {\n      if (error !== null) {\n        util.puts('exec error: ' + error);\n        return callback(error, null);\n      }\n      return callback(null, null);    \n  });    \n}\n\n// Write file\nGitFileOperations.fs_write = function(dir, file, content, callback) {  \n  // Let's make sure the parent directories exist, split the file into directories and content\n  var file_parts = file.split(\"/\");\n  var file_name = file_parts.pop()\n  var current_path = dir;\n  // Create missing sub directories\n  while(file_parts.length > 0) {\n    var dir_path = file_parts.shift();\n    current_path = current_path + \"/\" + dir_path;\n    // Check if the directory exists (if it does not then create it)\n    try {\n      fs.statSync(current_path);      \n    } catch(err) {\n      fs.mkdirSync(current_path, 16877);\n    }\n  }\n  \n  // Write the file to disk\n  current_path = dir + \"/\" + file;\n  // Append the entry to the file\n  fs.writeFile(current_path, content, callback);\n}\n\n\n\n\n\n\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/repository.js":"var util = require('util'),\n  GitObject = require('./git_object').GitObject,\n  fs = require('fs'),\n  LooseStorage = require('./loose_storage').LooseStorage,\n  PackStorage = require('./pack_storage').PackStorage,\n  BinaryParser = require('./binary_parser').BinaryParser;\n\nRepository = exports.Repository = function(git_directory, options) {  \n  var _git_directory = git_directory;\n  var _options = options ? options : {};\n  var _packs = [];\n  var _loose = null;\n  var _already_searched = {};\n  var self = this;\n  \n  Object.defineProperty(this, \"git_directory\", { get: function() { return _git_directory; }, set: function(value) { _git_directory = value; }, enumerable: true});    \n  Object.defineProperty(this, \"options\", { get: function() { return _options; }, set: function(value) { _options = value; }, enumerable: true});    \n  Object.defineProperty(this, \"already_searched\", { get: function() { return _already_searched; }, set: function(value) { _already_searched = value; }, enumerable: true});      \n  Object.defineProperty(this, \"packs\", { get: function() { return _packs; }, set: function(value) { _packs = value; }, enumerable: true});      \n  Object.defineProperty(this, \"loose\", { get: function() { return _loose; }, set: function(value) { _loose = value; }, enumerable: true});      \n}\n\n// Chomp text removing end carriage returns\nvar chomp = function chomp(raw_text) {\n  return raw_text.replace(/(\\n|\\r)+$/, '');\n}\n\nvar truncate_array = function(array, sha) {\n  \n}\n\n// takes the following options:\n//  :since - Time object specifying that you don't want commits BEFORE this\n//  :until - Time object specifying that you don't want commit AFTER this\n//  :first_parent - tells log to only walk first parent\n//  :path_limiter - string or array of strings to limit path\n//  :max_count - number to limit the output\nRepository.prototype.log = function(sha, options, callback) {\n  this.already_searched = {}\n  return walk_log(this, sha, options);\n}\n\nvar close = function(repo) {\n  if(repo.packs) {\n    repo.packs.forEach(function(pack) { \n      pack.close(); \n    });\n  }\n}\n\nvar git_path = function(repo, path) { return repo.git_directory + \"/\" + path; }\n\nvar initloose = function(repo) {\n  repo.loaded = [];\n  repo.loose = [];\n  load_loose(repo, git_path(repo, 'objects'));\n  load_alternate_loose(repo, git_path(repo, 'objects'));\n  return repo.loose;\n}\n\nvar load_loose = function(repo, path) {\n  repo.loaded.push(path);\n  try {\n    fs.statSync(path);\n    repo.loose.push(new LooseStorage(path));    \n  } catch (err) {\n    return;    \n  }\n}\n\nvar load_alternate_loose = function(repo, path) {\n  // load alternate loose too\n  var alt = path + '/info/alternates';\n  try {\n    fs.statSync(alt);\n    // Read and process all entries in the directory\n    var lines = fs.readFileSync(alt, 'utf8').split('\\n');\n    lines.length > 0 && lines[lines.length - 1] == '' ? lines.pop() : null;\n    // Iterate over alternate loose storage locations\n    lines.forEach(function(line) {      \n      // Only load the path once\n      if(repo.loaded.indexOf(chomp(line)) == -1) {        \n        if(line.substr(0, 2) == \"..\") {\n          line = fs.realpathSync(repo.git_directory + \"/\" + line);\n        }     \n\n        load_loose(repo, chomp(line));\n        load_alternate_loose(repo, chomp(line));        \n      }\n    });    \n  } catch(err) {}\n}\n\nvar initpacks = function(repo) {\n  close(repo);\n  repo.loaded_packs = [];\n  repo.packs = [];\n  load_packs(repo, git_path(repo, \"objects/pack\"));\n  load_alternate_packs(repo, git_path(repo, \"objects\"));\n  return repo.packs;\n}\n\nvar load_packs = function(repo, path) {\n  repo.loaded_packs.push(path);\n  try {\n    fs.statSync(path);\n    // Read and process all entries in the directory\n    fs.readdirSync(path).forEach(function(entry) {\n      // If we have a pack file create a new storage object\n      if(entry.match(/\\.pack$/i)) {\n        var pack = new PackStorage(path + \"/\" + entry);\n        // If we have specified the map for the pack then load the entire object map\n        if(repo.options[\"map_packfile\"]) {\n          pack.cache_objects();\n        }\n        // Add pack to list of packs in the repo\n        repo.packs.push(pack)\n      }\n    });\n  } catch (err) {    \n  }\n}\n\nvar load_alternate_packs = function(repo, path) {\n  var alt = path + \"/info/alternates\";\n  \n  try {\n    fs.statSync(alt);\n    // Read and process all entries in the directory\n    var lines = fs.readFileSync(alt, 'utf8').split('\\n');\n    lines.length > 0 && lines[lines.length - 1] == '' ? lines.pop() : null;\n\n    lines.forEach(function(line) {\n      if(line.substr(0, 2) == \"..\") {\n        line = fs.realpathSync(repo.git_directory + \"/\" + line);\n      }\n      \n      // Get pack file name\n      var full_pack = chomp(line) + \"/pack\";\n      if(repo.loaded_packs.indexOf(full_pack) == -1) {\n        load_packs(repo, full_pack);\n        load_alternate_packs(repo, chomp(line));\n      }\n    })\n  } catch(err) {    \n  }\n}\n\nvar get_raw_object_by_sha1 = function(repo, sha1o) {\n  if(!sha1o || sha1o == \"\" || sha1o.constructor != String) throw \"no such sha found\";\n  \n  var sha1 = '';\n  for(var i = 0; i < sha1o.length; i = i + 2) {\n    sha1 = sha1 + String.fromCharCode(parseInt(sha1o.substr(i, 2), 16));\n  }\n  // Init packs if we have none set yet\n  if(!repo.packs) initpacks(repo);\n  // Try packs\n  var packs = repo.packs;\n  for(var i = 0; i < packs.length; i++) {\n    var o = packs[i].find(sha1);    \n    if(o != null) return o;\n  }\n\n  if(!repo.loose) initloose(repo);\n  // Try loose storage\n  var looses = repo.loose;  \n  for(var i = 0; i < looses.length; i++) {\n    var o  = looses[i].find(sha1);\n    if(o) return o;\n  }\n\n  // try packs again maybe the object got packed in the meantime\n  initpacks(repo);\n  // Try packs\n  var packs = repo.packs;  \n  for(var i = 0; i < packs.length; i++) {\n    var o = packs[i].find(sha1);\n    if(o != null) return o;\n  }\n  \n  // No results throw an error that no sha pack object was found\n  throw \"no such sha found\";\n}\n\nRepository.prototype.get_object_by_sha1 = function(sha1) {\n  var r = get_raw_object_by_sha1(this, sha1);\n  if(!r) return null;\n  return GitObject.from_raw(r, this);\n}\n\n// returns true if the files in the path_limiter were changed or no path limiter\n// used by the log() function when passed with a path_limiter\nRepository.prototype.files_changed = function(tree_sha1, tree_sha2, path_limiter) {\n  if(path_limiter == null) return true;\n  // We got a path limiter, let's perform the diff to check for changes\n  var mod = this.quick_diff(tree_sha1, tree_sha2);\n  var files = mod.map(function(c) { return c[0]; });\n  path_limiter = Array.isArray(path_limiter) ? path_limiter : path_limiter != null ? [path_limiter] : [];\n  \n  for(var i = 0; i < path_limiter.length; i++) {\n    if(files.indexOf(path_limiter[i]) != -1) return true;\n  }\n  return false;\n}\n\n// Returns the raw file contents of this sha\nRepository.prototype.cat_file = function(sha) {\n  return this.get_object_by_sha1(sha).raw_content;\n}\n\n// Returns the file size (as an int) of this sha\nRepository.prototype.cat_file_size = function(sha) {\n  return get_raw_object_by_sha1(this, sha).content.length;\n}\n\n// Returns the file type as string of this sha\nRepository.prototype.cat_file_type = function(sha) {\n  return get_raw_object_by_sha1(this, sha).type;  \n}\n\n// returns the raw (cat-file) output for a tree\n// if given a commit sha, it will print the tree of that commit\n// if given a path limiter array, it will limit the output to those\n// if asked for recursive trees, will traverse trees\nRepository.prototype.ls_tree = function(sha, paths, recursive) {\n  var self = this;\n  paths = paths ? paths : [];\n  recursive = recursive ? recursive : false;\n\n  try {\n    if(paths.length > 0) {\n      // pathing\n      var part = [];\n      paths.forEach(function(path) {\n        part = part.concat(self.ls_tree_path(sha, path));\n      })\n      // Return the parts\n      return part.join(\"\\n\");\n    } else {\n      return this.get_raw_tree(sha, recursive);\n    }    \n  } catch (err) {\n    return '';\n  }\n}\n\nRepository.prototype.get_raw_tree = function(sha, recursive) {\n  var self = this;\n  recursive = recursive ? recursive : false;\n  var tree = null;\n  \n  var o = get_raw_object_by_sha1(this, sha);\n  if(o.type == 'commit') {\n    tree = this.get_object_by_sha1(sha).tree;\n  } else if(o.type == 'tag') {\n    var commit_sha = this.get_object_by_sha1(sha).object;\n    tree = this.get_object_by_sha1(commit_sha).tree;\n  } else if(o.type == 'tree') {\n    tree = sha;\n  } else {\n    return null;\n  }\n  \n  // If recursive execute next level of trees otherwise return the raw file\n  return recursive ? this.get_raw_trees(tree) : this.cat_file(tree);\n}\n\n// Grabs tree contents recursively,\n//  e.g. `git ls-tree -r sha`\nRepository.prototype.get_raw_trees = function(sha, path) {\n  var self = this;\n  path = path ? path : '';\n  var out = '';\n  \n  this.cat_file(sha).split('\\n').forEach(function(line) {\n    var parts = line.split(/\\s/);\n    var mode = parts[0], type = parts[1], sha = parts[2], name = parts[3];    \n    \n    if(type == 'tree') {\n      var full_name = path.length == 0 ? name : (path + '/' + name);\n      out = out + self.get_raw_trees(sha, full_name);\n    } else if(path.length == 0) {\n      out = out + line + '\\n';\n    } else {\n      out = out + line.replace(new RegExp(name, 'g'), (path + '/' + name)) + '\\n';\n    }\n  });  \n  // Return the out\n  return out;\n}\n\n// return array of tree entries\n// TODO : refactor this to remove the fugly\nRepository.prototype.ls_tree_path = function(sha, path, append) {\n  var self = this;\n  var tree = this.get_raw_tree(sha);\n  \n  if(path.match(/\\//)) {\n    var paths = path.split('/');\n    paths.length > 0 && paths[paths.length - 1] == '' ? paths.pop() : null;\n    var last = path.substr(path.length - 1, 1);\n\n    if((last == '/') && (paths.length == 1)) {\n      var append = append ? (append + \"/\" + paths[0]) : paths[0];\n      var dir_name = tree.split('\\n').filter(function(p) { return p.split('\\t')[1] == paths[0]; })[0];\n      \n      if(dir_name == null) throw \"no such path\";\n      var next_sha = dir_name.split(/ |\\t/)[2];\n      var tree = self.get_raw_tree(next_sha);\n      \n      tree = tree.split('\\n');\n      \n      if(append) {\n        var mod_tree = [];\n        tree.forEach(function(ent) {\n          var parts = ent.split('\\t');\n          var info = parts[0], fpath = parts[1];\n          mod_tree.push([info, (append + \"/\" + fpath)].join('\\t'));\n        });\n        return mod_tree;\n      } else {\n        return tree;\n      }\n    } else {\n      if(tree == null) throw \"no such path\";\n      var next_path = paths.shift();\n      var dir_name = tree.split('\\n').filter(function(p) { return p.split('\\t')[1] == next_path; })[0];\n      if(dir_name == null) throw \"no such path\";\n      var next_sha = dir_name.split(/ |\\t/)[2];\n      next_path = append ? (append + \"/\" + next_path) : next_path;\n      \n      if(last == '/') {\n        return self.ls_tree_path(next_sha, (paths.join('/') + '/'), next_path);\n      } else {\n        return self.ls_tree_path(next_sha, paths.join('/'), next_path);\n      }      \n    }    \n  } else {\n    if(tree == null) throw \"no such path\";\n    var tree = tree.split('\\n');\n    tree = tree.filter(function(p) { return p.split('\\t')[1] == path; });\n    \n    if(append) {\n      var mod_tree = [];\n      tree.forEach(function(ent) {\n        var parts = ent.split('\\t');\n        var info = parts[0], fpath = parts[1];\n        mod_tree.push([info, (append + '/' + fpath)].join('\\t'));\n      });\n      return mod_tree;\n    } else {\n      return tree;\n    }\n  }\n}\n\n// takes 2 tree shas and recursively walks them to find out what\n// files or directories have been modified in them and returns on\n// array of changes\n//  [ [full_path, 'added', tree1_hash, nil],\n//   [full_path, 'removed', nil, tree2_hash],\n//   [full_path, 'modified', tree1_hash, tree2_hash]\n//  ]\nRepository.prototype.quick_diff = function(tree1, tree2, path, recurse) {\n  var self = this;\n  path = path ? path : '.';\n  recurse = recurse ? recurse : true;\n  // Handle empty trees\n  var changed = [];  \n  if(tree1 == tree2) return changed;\n  \n  var t1 = tree1 ? this.list_tree(tree1) : null;\n  var t2 = tree2 ? this.list_tree(tree2) : null;\n  \n  // Check that we have tree 1 blob differences\n  if(t1) {\n    Object.keys(t1['blob']).forEach(function(file) {\n      var hsh = t1['blob'][file];\n      // Fetch the same file in tree 2\n      var t2_file = t2 ? t2['blob'][file] : null;\n      var full = path + \"/\" + file;\n      if(!t2_file) {\n        changed.push([full, 'added', hsh['sha'], null]);  // not in parent\n      } else if(hsh['sha'] != t2_file['sha']) {\n        changed.push([full, 'modified', hsh['sha'], t2_file['sha']]); // file changed\n      }\n    });\n  }\n    \n  \n  // Check tree 2 blobs\n  if(t2) {\n    Object.keys(t2['blob']).forEach(function(file) {\n      var hsh = t2 ? t2['blob'][file] : null;\n      if(t1 == null || t1['blob'][file] == null) {\n        changed.push([path + \"/\" + file, 'removed', null, hsh['sha']]);\n      }\n    });\n  }\n  \n  // Check for all the tree objects\n  if(t1) {\n    Object.keys(t1['tree']).forEach(function(dir) {\n      var hsh = t1['tree'][dir];\n      var t2_tree = t2 ? t2['tree'][dir] : null;\n      var full = path + \"/\" + dir;      \n      \n      if(!t2_tree) {\n        if(recurse) {\n          changed = changed.concat(self.quick_diff(hsh['sha'], null, full, true));\n        } else {\n          changed.push([full, 'added', hsh['sha', null]]);\n        }\n      } else if(hsh['sha'] != t2_tree['sha']) {\n        if(recurse) {\n          changed = changed.concat(self.quick_diff(hsh['sha'], t2_tree['sha'], full, true));\n        } else {\n          changed.push([full, 'modified', hsh['sha'], t2_tree['sha']]);\n        }\n      }\n    });    \n  }\n  \n  if(t2) {\n    Object.keys(t2['tree']).forEach(function(dir) {\n      var hsh = t2['tree'][dir];\n      var t1_tree = t1 ? t1['tree'][dir] : null;\n      \n      if(!t1_tree) {\n        if(recurse) {\n          changed = changed.concat(self.quick_diff(null, hsh['sha'], full, true));\n        } else {\n          changed.push([full, 'removed', null, hsh['sha']]);\n        }\n      }\n    });    \n  }\n  // Return all the changed files\n  return changed;\n}\n\n// returna 2-d hash of the tree\n// ['blob']['FILENAME'] = {:mode => '100644', :sha => SHA}\n// ['tree']['DIRNAME'] = {:mode => '040000', :sha => SHA}\nRepository.prototype.list_tree = function(sha) {\n  var data = {blob:{}, tree:{}, link:{}, commit:{}};\n  var object = this.get_object_by_sha1(sha);\n  object.entries.forEach(function(entry) {\n    data[entry.format_type][entry.name] = {mode:entry.format_type, sha:entry.sha1};\n  });\n  \n  return data;\n}\n\nvar walk_log = function(repo, sha, options, total_size) {\n  if(total_size == null) total_size = 0;  \n  if(repo.already_searched[sha]) return [];\n  // Add the sha to the list of allready searched for sha's\n  repo.already_searched[sha] = true;\n  // Empty array\n  var array = [];\n  var o = null, commit_sha = null, c = null, output = null;\n\n  if(sha) {\n    // Get the raw object\n    o = get_raw_object_by_sha1(repo, sha);\n\n    // Create a git object from the raw object\n    if(o.type == \"tag\") {\n      commit_sha = repo.get_object_by_sha1(sha).object;\n      c = repo.get_object_by_sha1(commit_sha);\n    } else {      \n      c = GitObject.from_raw(o, repo);\n    }\n    \n    // If it is not a commit\n    if(c.type != \"commit\") return [];  \n\n    // Add sha\n    var add_sha = true;    \n    // Check if the commit should be in the results\n    if(options[\"since\"] && (options[\"since\"] && options[\"since\"].constructor == Date) && (options[\"since\"] > c.committer.date)) {\n      add_sha = false;\n    }    \n    if(options[\"until\"] && (options[\"until\"] && options[\"until\"].constructor == Date) && (options[\"until\"] < c.committer.date)) {\n      add_sha = false;\n    }\n                \n    // Follow all parents unless --first-parent is specified\n    var subarray = [];\n    \n    if(c.parent.length == 0 && options[\"path_limiter\"]) {\n      add_sha = false;\n    }\n    \n    if(options[\"max_count\"] == null || ((array.length + total_size) < options[\"max_count\"])) {      \n      if(options[\"path_limiter\"] == null) {\n        output = c.raw_log(sha);\n        array.push([sha, output, c.committer.date]);\n      }\n\n      if(options[\"max_count\"] != null && (array.length + total_size) >= options[\"max_count\"]) {\n        return array;\n      }\n      \n      for(var i = 0; i < c.parent.length; i++) {\n        var psha = c.parent[i];\n        var tree = repo.get_object_by_sha1(psha).tree;\n        \n        if(psha && !repo.files_changed(c.tree, tree, options[\"path_limiter\"])) {\n          add_sha = false;\n        }\n        \n        // Walk the next level of the tree\n        var results = walk_log(repo, psha, options, (array.length + total_size));\n        subarray = subarray.concat(results); \n        if(options[\"first_parent\"]) break;\n      }\n      \n      if(options[\"path_limiter\"] != null && add_sha) {\n        output = c.raw_log(sha);\n        array.push([sha, output, c.comitter.date]);        \n      }\n      \n      if(add_sha) {\n        array = array.concat(subarray);\n      }\n    }\n  }\n  // Return all the commits\n  return array;\n}\n\nvar convert = function(d) {\n  return (\n    d.constructor === Date ? d :\n    d.constructor === Array ? new Date(d[0],d[1],d[2]) :\n    d.constructor === Number ? new Date(d) :\n    d.constructor === String ? new Date(d) :\n    typeof d === \"object\" ? new Date(d.year,d.month,d.date) :\n    NaN\n  );\n}\n\nvar compare = function(a,b) {\n  return (\n    isFinite(a=convert(a).valueOf()) &&\n    isFinite(b=convert(b).valueOf()) ?\n    (a>b)-(a<b) :\n    NaN\n  );\n}\n\nRepository.prototype.rev_list = function(sha, options, callback) {\n  try {\n    var end_sha = null;\n\n    if(Array.isArray(sha)) {\n      end_sha = sha[0], sha = sha[1];\n    }\n\n    // Walk the log\n    var log = this.log(sha, options);    \n    // Sort the log\n    log = log.sort(function(a, b) {\n      return compare(a[2], b[2])\n    }).reverse();\n    \n    // Truncate array\n    if(end_sha) {\n      log = truncate_arr(log, end_sha);\n    }\n\n    // Shorten the list if it's longer than max_count\n    if(options['max_count']) {      \n      var opt_len = parseInt(options['max_count']);\n      // If the length is less than the total log\n      if(opt_len < log.length) {\n        log = log.slice(0, opt_len);\n      }\n    }\n    \n    // Pretty print the result if option is specified\n    if(options['pretty'] == 'raw') {      \n      log = log.map(function(log_entry) { return log_entry[1]; }).join(\"\");\n    } else {\n      log = log.map(function(log_entry) { return log_entry[0]; }).join(\"\\n\");\n    }\n\n    // Return the log\n    callback(null, log);    \n  } catch (err) {\n    callback(err, null);\n  }\n}\n\n// Cut off the array at a specific point\nvar truncate_arr = function(arr, end_sha) {\n  var new_arr = [];\n  \n  for(var i = 0; i < arr.length; i++) {\n    var a = arr[i];\n    if(a[0] == sha) {\n      return new_arr;\n    }\n    new_arr.push(a);\n  }\n  return new_arr;\n}\n\n// Returns true/false if that sha exists in the db\nRepository.prototype.object_exists = function(sha1, callback) {\n  var self = this;\n  var sha_hex = '';\n  for(var i = 0; i < sha1.length; i = i + 2) {\n    sha_hex = sha_hex + String.fromCharCode(parseInt(sha1.substr(i, 2), 16));\n  }\n  \n  // Search in the packs\n  self.in_packs(sha_hex, function(err, result) {\n    if(err) return callback(err, result);\n    if(result) return callback(null, result);\n    \n    // Search in loose\n    self.in_loose(sha_hex, function(err, result) {\n      if(err) return callback(err, result);\n      if(result) return callback(null, result);\n      \n      // Search again in the packs after an init in case it appeared in the meantime\n      initpacks(self);\n      // Search in the packs\n      self.in_packs(sha_hex, function(err, result) {\n        if(err) return callback(err, result);\n        callback(null, result);\n      });\n    });\n  })\n}\n\n// Returns true if the hex-packed sha is in the packfile\nRepository.prototype.in_packs = function(sha_hex, callback) {\n  // Try packs\n  var packs = this.packs;\n  for(var i = 0; i < packs.length; i++) {\n    var o = packs[i].find(sha_hex);    \n    if(o != null) return callback(null, true);\n  }  \n  callback(null, false);\n}\n\n// Returns true if the hex-packed sha is in the loose objects\nRepository.prototype.in_loose = function(sha_hex, callback) {\n  if(!this.loose) initloose(this);  \n  // Try loose storage\n  var looses = this.loose;\n  for(var i = 0; i < looses.length; i++) {\n    var o  = looses[i].find(sha_hex);\n    if(o) return callback(null, true);\n  }\n  callback(null, false);  \n}\n\n// Get a subtree\nRepository.prototype.get_subtree = function(commit_sha, path, callback) {\n  var self = this;\n  // Fetch tree sha\n  var tree_sha = this.get_object_by_sha1(commit_sha).tree;\n  // Ensure we have a valid path\n  if(path && !(path == '' || path == '.' || path == './')) {\n    var paths = path.split('/');\n    \n    for(var i = 0; i < paths.length; i++) {\n      // Get the path element\n      path = paths[i];\n      // Ignore empty paths\n      if(paths[i] != '') {\n        var tree = this.get_object_by_sha1(tree_sha);\n        var entry = tree.entries.filter(function(e) { return e.name == path; }).shift();\n        \n        if(entry) {\n          tree_sha = entry.sha1;\n        } else {\n          return callback('no subtree located for ' + commit_sha, null);\n        }        \n      }\n    }\n  }\n  // Return the tree_sha\n  callback(null, tree_sha);\n}\n\nRepository.init = function(dir, bare, callback) {\n  try {    \n    var args = Array.prototype.slice.call(arguments, 0);\n    callback = args.pop();\n    dir = args.length ? args.shift() : true;\n    bare = args.length ? args.shift() : true;\n\n    // Create the directory if it does not exist\n    try { fs.statSync(dir); } catch(err) { fs.mkdirSync(dir, 16877); }\n    // Check if we are allready initialized\n    try { fs.statSync(dir + \"/objects\"); return callback(null, false) } catch(err) {};\n    // The directory does not exist so let's create it\n    create_initial_config(dir, bare);\n    // Create all the directories\n    fs.mkdirSync(dir + \"/refs\", 16877);\n    fs.mkdirSync(dir + \"/refs/heads\", 16877);\n    fs.mkdirSync(dir + \"/refs/tags\", 16877);\n    fs.mkdirSync(dir + \"/refs/info\", 16877);\n    fs.mkdirSync(dir + \"/refs/pack\", 16877);\n    fs.mkdirSync(dir + \"/branches\", 16877);\n    // Add basic files\n    add_file(dir, 'description', 'Unnamed repository; edit this file to name it for gitweb.');\n    add_file(dir, 'HEAD', 'ref: refs/heads/master\\n');\n    // Create hooks directory\n    fs.mkdirSync(dir + \"/hooks\", 16877);\n    // Add empty shell scripts\n    add_file(dir + \"/hooks\", 'applypatch-msg', '# add shell script and make executable to enable');\n    add_file(dir + \"/hooks\", 'post-commit', '# add shell script and make executable to enable');\n    add_file(dir + \"/hooks\", 'post-receive', '# add shell script and make executable to enable');\n    add_file(dir + \"/hooks\", 'post-update', '# add shell script and make executable to enable');\n    add_file(dir + \"/hooks\", 'pre-applypatch', '# add shell script and make executable to enable');\n    add_file(dir + \"/hooks\", 'pre-commit', '# add shell script and make executable to enable');\n    add_file(dir + \"/hooks\", 'pre-rebase', '# add shell script and make executable to enable');\n    add_file(dir + \"/hooks\", 'update', '# add shell script and make executable to enable');\n    // Create info directory\n    fs.mkdirSync(dir + \"/info\", 16877);\n    add_file(dir, 'info/exclude', \"# *.[oa]\\n# *~\");\n    callback(null, self);\n  } catch(err) {\n    callback(err, null);\n  }\n}\n\nvar create_initial_config = function(dir, bare) {\n  var bare_status = bare ? 'true' : 'false';\n  var config = \"[core]\\n\\trepositoryformatversion = 0\\n\\tfilemode = true\\n\\tbare = \" + bare_status + \"\\n\\tlogallrefupdates = true\";\n  add_file(dir, 'config', config);\n}\n\nvar add_file = function(dir, name, content) {\n  fs.writeFileSync(dir + \"/\" + name, content);\n}\n\n// writes a raw object into the git repo\nRepository.prototype.put_raw_object = function(content, type, callback) {\n  return this.loose[0].put_raw_object(content, type, callback);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/git_object.js":"var GitCommit = require('./internal/git_commit').GitCommit,\n  GitTree = require('./internal/git_tree').GitTree,\n  GitTag = require('./internal/git_tag').GitTag,\n  GitBlob = require('./internal/git_blob').GitBlob;\n\nvar GitObject = exports.GitObject = function() {}\n\nGitObject.from_raw = function(raw_object, repository) {  \n  if(raw_object.type == \"blob\") {\n    return GitBlob.from_raw(raw_object, repository);\n  } else if(raw_object.type == \"tree\") {\n    return GitTree.from_raw(raw_object, repository);\n  } else if(raw_object.type == \"commit\") {\n    return GitCommit.from_raw(raw_object, repository);\n  } else if(raw_object.type == \"tag\") {\n    return GitTag.from_raw(raw_object, repository);\n  } else {\n    throw \"got invalid object-type\";\n  }\n}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/internal/git_commit.js":"var util = require('util'), \n  UserInfo = require('../user_info').UserInfo;\n\nvar GitCommit = exports.GitCommit = function(tree, parent, author, committer, message, headers, repository) {\n  var _tree = tree, _parent = parent, _author = author, _committer = committer, _message = message, _headers = headers, _repository = repository;\n\n  Object.defineProperty(this, \"tree\", { get: function() { return _tree; }, enumerable: true});    \n  Object.defineProperty(this, \"parent\", { get: function() { return _parent; }, enumerable: true});    \n  Object.defineProperty(this, \"author\", { get: function() { return _author; }, enumerable: true});    \n  Object.defineProperty(this, \"committer\", { get: function() { return _committer; }, enumerable: true});    \n  Object.defineProperty(this, \"message\", { get: function() { return _message; }, enumerable: true});    \n  Object.defineProperty(this, \"headers\", { get: function() { return _headers; }, enumerable: true});    \n  Object.defineProperty(this, \"repository\", { get: function() { return _repository; }, enumerable: true});      \n  Object.defineProperty(this, \"type\", { get: function() { return \"commit\"; }, enumerable: true});     \n  \n  // Raw content of commit\n  Object.defineProperty(this, \"raw_content\", { get: function() {\n    return \"tree \" + _tree + \"\\n\" \n      + _parent.map(function(i) { return \"parent \" + i +\"\\n\"; }).join('') \n      + \"author \" + _author + \"\\ncommitter \" + _committer + \"\\n\\n\" + _message;\n  }, enumerable: true});        \n}\n\n// Create a commit from a raw object\nGitCommit.from_raw = function(raw_object, repository) {\n  var parent = [];\n  var tree = null, author = null, committer = null;\n  \n  // Split the text but only grab the 2 first blocks\n  var split_result = raw_object.content.split(/\\n\\n/);  \n  var headers = split_result.shift();  \n  var message = split_result.join(\"\\n\\n\");\n  \n  // get all the headers\n  var all_headers = headers.split(/\\n/).map(function(header) { \n    var parts = header.split(/ /);\n    return [parts.shift(), parts.join(\" \")];\n  })\n  // Iterate over all the headers\n  all_headers.forEach(function(header) {\n    var key = header[0];\n    var value = header[1];\n    \n    if(key == \"tree\") {\n      tree = value;\n    } else if(key == \"parent\") {\n      parent.push(value);\n    } else if(key == \"author\") {\n      author = new UserInfo(value);\n    } else if(key == \"committer\") {\n      committer = new UserInfo(value);\n    } else {\n      // Unknow header\n      util.puts(\"unknow header '\" + key + \"' in commit \" + raw_object.sha_hex())\n    }\n  })\n  \n  if(!tree && !author && !committer) {\n    throw \"incomplete raw commit object\";\n  }  \n  // Return the git commit object\n  return new GitCommit(tree, parent, author, committer, message, headers, repository);\n}\n\nGitCommit.prototype.raw_log = function(sha1) {\n  var output = \"commit \" + sha1 + \"\\n\";\n  output = output + this.headers + \"\\n\\n\";\n  var lines = this.message.split(\"\\n\");    \n  // Remove the last line which will be empty\n  for(var i = 0; i < (lines.length > 1 ? lines.length - 1 : lines.length); i++) {\n    output = output + '    ' + lines[i] + '\\n';\n  }\n  // Return the output\n  return output + '\\n';\n}\n\n\n\n\n\n\n\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/user_info.js":"var util = require('util'),\n  StringUtil = require('../sprintf/sprintf').StringUtil;\n\nvar UserInfo = exports.UserInfo = function(string) {\n  var _email = '', _date = new Date(), _offset = 0, _name = '';\n   \n  // Parse the content\n  var match_results = string.match(/^(.*?) <(.*)> (\\d+) ([+-])0*(\\d+?)$/);\n  // If we don't have a correct match set parse it partially\n  if(!match_results) {\n    if(string.match(/<.+>/)) {\n      var sub_match = string.match(/(.*) <(.+?)>/);\n      _name = sub_match[1];\n      _email = sub_match[2];\n    } else {\n      _name = string;\n    }\n  } else {\n    _name = match_results[1];\n    _email = match_results[2];\n    _date = new Date(parseInt(match_results[3] * 1000));\n    _offset = (match_results[4] == \"-\" ? -1 : 1) * parseInt(match_results[5]);\n  }\n\n  // Define properties\n  Object.defineProperty(this, \"name\", { get: function() { return _name; }, enumerable: true});    \n  Object.defineProperty(this, \"email\", { get: function() { return _email; }, enumerable: true});    \n  Object.defineProperty(this, \"date\", { get: function() { return _date; }, enumerable: true});  \n  Object.defineProperty(this, \"offset\", { get: function() { return _offset; }, enumerable: true});  \n}\n\nUserInfo.prototype.toString = function() {\n  // Ensure correct formating for the offset\n  var offset_str = this.offset.toString();\n  var add_string = '';\n  if(offset_str.length < 5) {\n    for(var i = 0; i < (5 - offset_str.length); i++) { add_string += '0'; }\n    offset_str = offset_str.substr(0, 1) + add_string + offset_str.substr(1);\n  }  \n  // Return the userinfo as a string\n  return \"\" + this.name + \" <\" + this.email + \"> \" + (this.date.getTime()/1000) + \" \" + offset_str;\n}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/sprintf/sprintf.js":"/**\nsprintf() for JavaScript 0.6\n\nCopyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of sprintf() for JavaScript nor the\n      names of its contributors may be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nChangelog:\n2007.04.03 - 0.1:\n - initial release\n2007.09.11 - 0.2:\n - feature: added argument swapping\n2007.09.17 - 0.3:\n - bug fix: no longer throws exception on empty paramenters (Hans Pufal)\n2007.10.21 - 0.4:\n - unit test and patch (David Baird)\n2010.05.09 - 0.5:\n - bug fix: 0 is now preceeded with a + sign\n - bug fix: the sign was not at the right position on padded results (Kamal Abdali)\n - switched from GPL to BSD license\n2010.05.22 - 0.6:\n - reverted to 0.4 and fixed the bug regarding the sign of the number 0\n Note:\n Thanks to Raphael Pigulla <raph (at] n3rd [dot) org> (http://www.n3rd.org/)\n who warned me about a bug in 0.5, I discovered that the last update was\n a regress. I appologize for that.\n**/\n\nvar StringUtil = exports.StringUtil = function() {};\nStringUtil.str_repeat = str_repeat;\nStringUtil.sprintf = sprintf;\n\nfunction str_repeat(i, m) {\n\tfor (var o = []; m > 0; o[--m] = i);\n\treturn o.join('');\n}\n\nfunction sprintf() {\n\tvar i = 0, a, f = arguments[i++], o = [], m, p, c, x, s = '';\n\twhile (f) {\n\t\tif (m = /^[^\\x25]+/.exec(f)) {\n\t\t\to.push(m[0]);\n\t\t}\n\t\telse if (m = /^\\x25{2}/.exec(f)) {\n\t\t\to.push('%');\n\t\t}\n\t\telse if (m = /^\\x25(?:(\\d+)\\$)?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fosuxX])/.exec(f)) {\n\t\t\tif (((a = arguments[m[1] || i++]) == null) || (a == undefined)) {\n\t\t\t\tthrow('Too few arguments.');\n\t\t\t}\n\t\t\tif (/[^s]/.test(m[7]) && (typeof(a) != 'number')) {\n\t\t\t\tthrow('Expecting number but found ' + typeof(a));\n\t\t\t}\n\t\t\tswitch (m[7]) {\n\t\t\t\tcase 'b': a = a.toString(2); break;\n\t\t\t\tcase 'c': a = String.fromCharCode(a); break;\n\t\t\t\tcase 'd': a = parseInt(a); break;\n\t\t\t\tcase 'e': a = m[6] ? a.toExponential(m[6]) : a.toExponential(); break;\n\t\t\t\tcase 'f': a = m[6] ? parseFloat(a).toFixed(m[6]) : parseFloat(a); break;\n\t\t\t\tcase 'o': a = a.toString(8); break;\n\t\t\t\tcase 's': a = ((a = String(a)) && m[6] ? a.substring(0, m[6]) : a); break;\n\t\t\t\tcase 'u': a = Math.abs(a); break;\n\t\t\t\tcase 'x': a = a.toString(16); break;\n\t\t\t\tcase 'X': a = a.toString(16).toUpperCase(); break;\n\t\t\t}\n\t\t\ta = (/[def]/.test(m[7]) && m[2] && a >= 0 ? '+'+ a : a);\n\t\t\tc = m[3] ? m[3] == '0' ? '0' : m[3].charAt(1) : ' ';\n\t\t\tx = m[5] - String(a).length - s.length;\n\t\t\tp = m[5] ? str_repeat(c, x) : '';\n\t\t\to.push(s + (m[4] ? a + p : p + a));\n\t\t}\n\t\telse {\n\t\t\tthrow('Huh ?!');\n\t\t}\n\t\tf = f.substring(m[0].length);\n\t}\n\treturn o.join('');\n}\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/internal/git_tree.js":"var util = require('util'),\n  BinaryParser = require('../binary_parser').BinaryParser,\n  DirectoryEntry = require('../internal/directory_entry').DirectoryEntry;\n\nvar GitTree = exports.GitTree = function(entries, repository) {  \n  var _entries = entries ? entries : [], _repository = repository;\n  \n  // Internal properties\n  Object.defineProperty(this, \"entries\", { get: function() { return _entries; }, set: function(value) { _entries = value; }, enumerable: true});\n  Object.defineProperty(this, \"repository\", { get: function() { return _repository; }, set: function(value) { _repository = value; }, enumerable: true});\n  Object.defineProperty(this, \"type\", { get: function() { return \"tree\"; }, enumerable: true});      \n\n  // Raw content of commit\n  Object.defineProperty(this, \"raw_content\", { get: function() {\n    return _entries.map(function(e) {\n      return [[e.format_mode, e.format_type, e.sha1].join(' '), e.name].join('\\t')\n    }).join('\\n');    \n  }, enumerable: true});        \n}\n\nvar read_until_chr = function(index, content, char) {\n  var found = false;\n  var content_length = content.length;\n  var chr_code = char.charCodeAt(0);\n  var offset = 0;\n  \n  // Search until we locate the content\n  while(!found && (index + offset) < content_length) {\n    if(content.charCodeAt(index + offset) == chr_code) found = true;\n    offset = offset + 1;\n  }  \n    \n  // Extract content and return\n  return content.substr(index, offset - 1);\n}\n\nvar to_hex_string = function(string) {\n  var hexString = '';\n  for(var index = 0; index < string.length; index++) {\n    var value = BinaryParser.toByte(string.substr(index, 1));\n    var number = value <= 15 ? \"0\" + value.toString(16) : value.toString(16);\n    hexString = hexString + number;\n  }\n  return hexString;\n};\n\n// Create Tree Object from Raw stream\nGitTree.from_raw = function(raw_object, repository) {\n  var entries = [];\n  var index = 0;\n  var content_length = raw_object.content.length;\n  var content = raw_object.content;\n  \n  // Parse the content\n  while(index < content_length) {\n    var mode = read_until_chr(index, content, ' ');\n    index = index + mode.length + 1;\n    var file_name = read_until_chr(index, content, '\\0');\n    index = index + file_name.length + 1;\n    var raw_sha = content.substr(index, 20);\n    index = index + raw_sha.length;\n    var sha = to_hex_string(raw_sha);\n    \n    // Add the Entry to the directory list\n    entries.push(new DirectoryEntry(mode, file_name, sha));\n  }\n  \n  // Return a tree with all the entries\n  return new GitTree(entries, repository);\n}\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/internal/directory_entry.js":"var StringUtil = require('../../sprintf/sprintf').StringUtil;\n\nvar S_IFMT = parseInt('00170000', 8);\nvar S_IFLNK = parseInt('0120000', 8);\nvar S_IFREG = parseInt('0100000', 8);\nvar S_IFDIR = parseInt('0040000', 8);\nvar S_IFGITLINK = parseInt('0160000', 8);\n\nvar DirectoryEntry = exports.DirectoryEntry = function(mode, file_name, sha1) {\n  var _mode = 0, _name = file_name, _sha1 = sha1;\n  var self = this;\n  \n  // Process the mode to correctly get the right value\n  for(var i = 0; i < mode.length; i++) {\n    _mode = (_mode << 3) | (mode.charCodeAt(i) - '0'.charCodeAt(0));\n  }\n  \n  // Internal properties\n  Object.defineProperty(this, \"mode\", { get: function() { return _mode; }, set: function(value) { _mode = value; }, enumerable: true});\n  Object.defineProperty(this, \"name\", { get: function() { return _name; }, set: function(value) { _name = value; }, enumerable: true});\n  Object.defineProperty(this, \"sha1\", { get: function() { return _sha1; }, set: function(value) { _sha1 = value; }, enumerable: true});\n  // Return the type of entry\n  Object.defineProperty(this, \"type\", { get: function() { \n      var type = self.mode & S_IFMT;\n      if(type == S_IFGITLINK) {\n        return 'submodule';\n      } else if(type == S_IFLNK) {\n        return 'link';\n      } else if(type == S_IFDIR) {\n        return 'directory';\n      } else if(type == S_IFREG) {\n        return 'file';\n      } else {\n        return null;\n      }    \n    }, enumerable: true});\n\n  Object.defineProperty(this, \"format_type\", { get:function() {\n    var type = this.type;\n    if(type == 'link') {\n      return 'link';\n    } else if(type == 'directory') {\n      return 'tree';\n    } else if(type == 'file') {\n      return 'blob';\n    } else if(type == 'submodule') {\n      return 'commit';\n    }\n  }, enumerable: false});\n\n  Object.defineProperty(this, \"format_mode\", { get:function() {\n    return StringUtil.sprintf(\"%06o\", _mode);\n  }, enumerable: false});  \n  \n  // Ensure we don't have an illegal type of directory\n  if([S_IFLNK, S_IFDIR, S_IFREG, S_IFGITLINK].indexOf(_mode & S_IFMT) == -1) {\n    throw \"unknown type for directory entry\";\n  }   \n}\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/internal/git_tag.js":"var util = require('util'),\n  UserInfo = require('../user_info').UserInfo;\n\nvar GitTag = exports.GitTag = function(object, type, tag, tagger, message, repository) {\n  var _object = object, _type = type, _tag = tag, _tagger = tagger, _message = message, _repository = repository;\n  \n  Object.defineProperty(this, \"repository\", { get: function() { return _repository; }, set: function(value) { _repository = value; }, enumerable: true});    \n  Object.defineProperty(this, \"object\", { get: function() { return _object; }, set: function(value) { _object = value; }, enumerable: true});    \n  // Object.defineProperty(this, \"type\", { get: function() { return _type; }, set: function(value) { _type = value; }, enumerable: true});    \n  Object.defineProperty(this, \"tag\", { get: function() { return _tag; }, set: function(value) { _tag = value; }, enumerable: true});    \n  Object.defineProperty(this, \"tagger\", { get: function() { return _tagger; }, set: function(value) { _tagger = value; }, enumerable: true});    \n  Object.defineProperty(this, \"message\", { get: function() { return _message; }, set: function(value) { _message = value; }, enumerable: true});    \n  Object.defineProperty(this, \"type\", { get: function() { return \"tag\"; }, enumerable: true});\n  \n  Object.defineProperty(this, \"raw_content\", { get: function() { \n      return \"object \" + _object + \"\\ntype \" + _type + \"\\ntag \" + _tag + \"\\ntagger \" + _tagger + \" \" + _message + \"\\n\\n\";\n    }, enumerable: false});\n}\n\nGitTag.from_raw = function(raw_object, repository) {\n  var parts = raw_object.content.split(\"\\n\\n\");\n  var headers = parts.shift();\n  var message = parts.join(/\\n\\n/);\n  \n  // Further split the headers\n  headers = headers.split(/\\n/).map(function(header) { \n    var parts = header.split(/ /);\n    return [parts.shift(), parts.join(\" \")];\n  })\n\n  // Initialize base variables\n  var object = '', type = '', tag = '', tagger = '';\n  \n  headers.forEach(function(header) {\n    var key = header[0];\n    var value = header[1];\n    \n    if(key == 'object') {\n      object = value;\n    } else if (key == 'type') {\n      if(['blob', 'tree', 'commit', 'tag'].indexOf(value) == -1) {\n        throw \"invalid type in tag\";\n      }\n      // Set the type\n      type = value;\n    } else if(key == 'tag') {\n      tag = value;\n    } else if(key == 'tagger') {\n      tagger = new UserInfo(value);\n    } else {\n      util.puts(\"unknown header '\" + key);\n    }\n  });\n  \n  // If we have an illegal tag object\n  if(object == null || type == null || tag == null || tagger == null) {\n    throw \"incomplete raw tag object\";\n  }\n  // Return the tag\n  return new GitTag(object, type, tag, tagger, message, repository);\n}\n\n\n\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/internal/git_blob.js":"var util = require('util');\n\nvar GitBlob = exports.GitBlob = function(content, repository) {\n  var _content = content, _repository = repository;\n\n  Object.defineProperty(this, \"content\", { get: function() { return _content; }, set: function(value) { _content = value; }, enumerable: true});\n  Object.defineProperty(this, \"repository\", { get: function() { return _repository; }, set: function(value) { _repository = value; }, enumerable: false});\n  Object.defineProperty(this, \"type\", { get: function() { return \"blob\"; }, enumerable: true});      \n  Object.defineProperty(this, \"raw_content\", { get: function() { return _content; }, set: function(value) { _content = value; }, enumerable: true});\n}\n\nGitBlob.from_raw = function(raw_object, repository) {\n  return new GitBlob(raw_object.content);\n}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/loose_storage.js":"var util = require('util'),\n  fs = require('fs'),\n  BinaryParser = require('./binary_parser').BinaryParser,\n  Zlib = require('../zlib/zlib').Zlib,\n  RawObject = require('./raw_object').RawObject,\n  crypto = require('crypto'),\n  zlib = require('zlib');\n\nvar OBJ_TYPES = [null, \"commit\", \"tree\", \"blob\", \"tag\"];\n\nLooseStorage = exports.LooseStorage = function(directory) {\n  var _directory = directory;\n\n  Object.defineProperty(this, \"directory\", { get: function() { return _directory; }, set: function(value) { _directory = value; }, enumerable: true});    \n}\n\nLooseStorage.prototype.find = function(sha1) {\n  try {\n    sha1 = to_hex_string(sha1);\n    // If we don't have a valid sha\n    if(sha1.length != 40) return null;\n    // Directory path\n    var path = this.directory + \"/\" + sha1.substring(0, 2) + '/' + sha1.substring(2, 40);\n    return this.get_raw_object(fs.readFileSync(path));    \n  } catch(err) {\n    return null;\n  }\n}\n\n// Read and parse the raw object\nLooseStorage.prototype.get_raw_object = function(buf) {\n  if(buf.length < 2) throw \"object file too small\";\n\n  // Set up variables\n  var type = null;\n  var size = null;\n  var used = null;\n  var content = null;\n\n  if(this.is_legacy_loose_object(buf)) {\n    content = new Zlib.Unzip(buf).unzip();\n    content = Array.isArray(content) ? content[0] : content;\n    // Let's split the content up\n    var parts = content.split(/\\0/)\n    var header = parts.shift();\n    content = parts.join(\"\\0\");\n    \n    // if no header or content we got an invalid object header\n    if(header == null || content == null) throw \"invalid object header\";\n    \n    // Split out the header\n    parts = header.split(/ /);\n    type = parts[0];\n    size = parts[1];\n    // Check that we have a valid type\n    if(['blob', 'tree', 'commit', 'tag'].indexOf(type) == -1 || !size.match(/^\\d+$/)) throw \"invalid object header\";\n    // Convert parts\n    size = parseInt(size, 10);    \n  } else {\n    var parts = this.unpack_object_header_gently(buf);\n    type = parts[0];\n    size = parts[1];\n    used = parts[2];\n    // Unpack content\n    content = new Zlib.Unzip(buf.slice(used, buf.length)).unzip();\n    content = Array.isArray(content) ? content[0] : content;\n  }\n  // Return a raw object\n  return new RawObject(type, content);\n}\n\nLooseStorage.prototype.unpack_object_header_gently = function(buf) {\n  var used = 0\n  var c = buf[used];\n  used = used + 1;\n  \n  var type = (c >> 4) & 7;\n  var size = c & 15;\n  var shift = 4;\n  \n  while(c & 0x80 != 0) {\n    if(buf.length <= used) throw \"object file too short\";\n    // Get next char\n    c = buf[used];\n    used = used + 1;\n    // Calculate size\n    size = size + ((c & 0x7f) << shift);    \n  }\n  \n  // Fetch the type\n  type = OBJ_TYPES[type];\n  // Check that we have a valid type\n  if(['blob', 'tree', 'commit', 'tag'].indexOf(type) == -1) throw \"invalid loose object type\";\n  return [type, size, used];\n}\n\nLooseStorage.prototype.is_legacy_loose_object = function(buf) {\n  var word = (buf[0] << 8) + buf[1];\n  return buf[0] == 0x78 && word % 31 == 0;\n}\n\nvar to_hex_string = function(string) {\n  var hexString = '';\n  for(var index = 0; index < string.length; index++) {\n    var value = BinaryParser.toByte(string.substr(index, 1));\n    var number = value <= 15 ? \"0\" + value.toString(16) : value.toString(16);\n    hexString = hexString + number;\n  }\n  return hexString;\n};\n\n// currently, I'm using the legacy format because it's easier to do\n// this function takes content and a type and writes out the loose object and returns a sha\nLooseStorage.prototype.put_raw_object = function(content, type, callback) {\n  var self = this;\n  // Retrieve size of message\n  var size = content.length.toString();    \n  // Verify that header is ok\n  LooseStorage.verify_header(type, size);  \n  // Create header\n  var header = \"\" + type + \" \" + size + \"\\0\";\n  var store = header + content;  \n  // Use node crypto library to create sha1 hash\n  var hash = crypto.createHash(\"sha1\");\n  hash.update(store);\n  // Return the hash digest\n  var sha1 = hash.digest('hex');\n  // Create path\n  var path = this.directory +  \"/\" + sha1.substr(0, 2) + '/' + sha1.substr(2);\n  \n  try {\n    fs.statSync(path);\n  } catch(err) {    \n    // Deflate the data\n    var data = zlib.gunzip(store, function (err, buffer) {\n      if (err) {\n        throw err;\n      }\n\n      // File does not exist create the directory\n      fs.mkdir(self.directory + \"/\" + sha1.substr(0, 2), 16877, function (err) {\n        if (err) {\n          throw err;\n        }\n\n        fs.writeFile(path, data, 'binary', function (err) {\n          if (err) {\n            throw err;\n          }\n\n          callback(sha1);\n        });\n      });\n    });\n  }\n}\n\nLooseStorage.verify_header = function(type, size) {\n  if([\"blob\", \"tree\", \"commit\", \"tag\"].indexOf(type) == -1 || size.match(/^\\d+$/) == null) {\n    throw \"invalid object header\";\n  }\n}\n\n\n\n\n\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/zlib/zlib.js":"/*\n    Copyright 2008,2009\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with JSXGraph.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @fileoverview Utilities for uncompressing and base64 decoding\n */\n\n/**\n  * @class Util class\n  * Class for gunzipping, unzipping and base64 decoding of files.\n  * It is used for reading GEONExT, Geogebra and Intergeo files.\n  *\n  * Only Huffman codes are decoded in gunzip.\n  * The code is based on the source code for gunzip.c by Pasi Ojala \n  * @see <a href=\"http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c\">http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c</a>\n  * @see <a href=\"http://www.cs.tut.fi/~albert\">http://www.cs.tut.fi/~albert</a>\n  */\nvar util = require('util');\nvar Zlib = exports.Zlib = {};\n      \n/**\n * Unzip zip files\n */\nZlib.Unzip = function (barray){\n    var outputArr = [],\n        output = \"\",\n        debug = false,\n        gpflags,\n        files = 0,\n        unzipped = [],\n        crc,\n        buf32k = new Array(32768),\n        bIdx = 0,\n        modeZIP=false,\n\n        CRC, SIZE,\n    \n        bitReverse = [\n        0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,\n        0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,\n        0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,\n        0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,\n        0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,\n        0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,\n        0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,\n        0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,\n        0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,\n        0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,\n        0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,\n        0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,\n        0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,\n        0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,\n        0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,\n        0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,\n        0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,\n        0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,\n        0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,\n        0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,\n        0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,\n        0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,\n        0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,\n        0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,\n        0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,\n        0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,\n        0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,\n        0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,\n        0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,\n        0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,\n        0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,\n        0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff\n    ],\n    \n    cplens = [\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n    ],\n\n    cplext = [\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99\n    ], /* 99==invalid */\n\n    cpdist = [\n        0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d,\n        0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1,\n        0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01,\n        0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001\n    ],\n\n    cpdext = [\n        0,  0,  0,  0,  1,  1,  2,  2,\n        3,  3,  4,  4,  5,  5,  6,  6,\n        7,  7,  8,  8,  9,  9, 10, 10,\n        11, 11, 12, 12, 13, 13\n    ],\n    \n    border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n    \n    bA = barray,\n\n    bytepos=0,\n    bitpos=0,\n    bb = 1,\n    bits=0,\n    \n    NAMEMAX = 256,\n    \n    nameBuf = [],\n    \n    fileout;\n    \n    function readByte(){\n        bits+=8;\n        if (bytepos<bA.length){\n            //if (debug)\n            //    document.write(bytepos+\": \"+bA[bytepos]+\"<br>\");\n            // util.debug(bA[bytepos++].toString(16))\n            // return String.fromCharCode(bA[bytepos++]);\n            return bA[bytepos++];\n        } else\n            return -1;\n    };\n\n    function byteAlign(){\n        bb = 1;\n    };\n    \n    function readBit(){\n        var carry;\n        bits++;\n        carry = (bb & 1);\n        bb >>= 1;\n        if (bb==0){\n            bb = readByte();\n            carry = (bb & 1);\n            bb = (bb>>1) | 0x80;\n        }\n        return carry;\n    };\n\n    function readBits(a) {\n        var res = 0,\n            i = a;\n    \n        while(i--) {\n            res = (res<<1) | readBit();\n        }\n        if(a) {\n            res = bitReverse[res]>>(8-a);\n        }\n        return res;\n    };\n        \n    function flushBuffer(){\n        //document.write('FLUSHBUFFER:'+buf32k);\n        bIdx = 0;\n    };\n    function addBuffer(a){\n        SIZE++;\n        //CRC=updcrc(a,crc);\n        buf32k[bIdx++] = a;\n        outputArr.push(String.fromCharCode(a));\n        //output+=String.fromCharCode(a);\n        if(bIdx==0x8000){\n            //document.write('ADDBUFFER:'+buf32k);\n            bIdx=0;\n        }\n    };\n    \n    function HufNode() {\n        this.b0=0;\n        this.b1=0;\n        this.jump = null;\n        this.jumppos = -1;\n    };\n\n    var LITERALS = 288;\n    \n    var literalTree = new Array(LITERALS);\n    var distanceTree = new Array(32);\n    var treepos=0;\n    var Places = null;\n    var Places2 = null;\n    \n    var impDistanceTree = new Array(64);\n    var impLengthTree = new Array(64);\n    \n    var len = 0;\n    var fpos = new Array(17);\n    fpos[0]=0;\n    var flens;\n    var fmax;\n    \n    function IsPat() {\n        while (1) {\n            if (fpos[len] >= fmax)\n                return -1;\n            if (flens[fpos[len]] == len)\n                return fpos[len]++;\n            fpos[len]++;\n        }\n    };\n\n    function Rec() {\n        var curplace = Places[treepos];\n        var tmp;\n        if (debug)\n          util.debug(\"len: \" + len + \" treepos: \" + treepos)\n        if(len==17) { //war 17\n            return -1;\n        }\n        treepos++;\n        len++;\n    \t\n        tmp = IsPat();\n        if (debug)\n          util.debug(\"IsPat \" + tmp)\n        if(tmp >= 0) {\n            curplace.b0 = tmp;    /* leaf cell for 0-bit */\n            if (debug)\n              util.debug(\"b0 \" + curplace.b0)\n        } else {\n        /* Not a Leaf cell */\n        curplace.b0 = 0x8000;\n        if (debug)\n          util.debug(\"b0 \" + curplace.b0)\n        if(Rec())\n            return -1;\n        }\n        tmp = IsPat();\n        if(tmp >= 0) {\n            curplace.b1 = tmp;    /* leaf cell for 1-bit */\n            if (debug)\n              util.debug(\"b1 \" + curplace.b1);\n            curplace.jump = null;    /* Just for the display routine */\n        } else {\n            /* Not a Leaf cell */\n            curplace.b1 = 0x8000;\n            if (debug)\n              util.debug(\"b1 \" + curplace.b1);\n            curplace.jump = Places[treepos];\n            curplace.jumppos = treepos;\n            if(Rec())\n                return -1;\n        }\n        len--;\n        return 0;\n    };\n\n    function CreateTree(currentTree, numval, lengths, show) {\n        var i;\n        /* Create the Huffman decode tree/table */\n        //document.write(\"<br>createtree<br>\");\n        if (debug)\n          util.debug(\"currentTree \" + currentTree + \" numval \" + numval + \" lengths \" + lengths + \" show \" + show);\n        Places = currentTree;\n        treepos=0;\n        flens = lengths;\n        fmax  = numval;\n        for (i=0;i<17;i++)\n            fpos[i] = 0;\n        len = 0;\n        if(Rec()) {\n            //fprintf(stderr, \"invalid huffman tree\\n\");\n            if (debug)\n              util.debug(\"invalid huffman tree\");\n            return -1;\n        }\n        if (debug){\n          util.debug(\"Tree: \" + Places.length);\n        \tfor (var a=0;a<32;a++){\n        \t  util.debug(\"Places[\" + a + \"].b0=\" + Places[a].b0);\n        \t  util.debug(\"Places[\" + a + \"].b1=\" + Places[a].b1);\n        \t}\n        }\n    \n        /*if(show) {\n            var tmp;\n            for(tmp=currentTree;tmp<Places;tmp++) {\n                fprintf(stdout, \"0x%03x  0x%03x (0x%04x)\",tmp-currentTree, tmp->jump?tmp->jump-currentTree:0,(tmp->jump?tmp->jump-currentTree:0)*6+0xcf0);\n                if(!(tmp.b0 & 0x8000)) {\n                    //fprintf(stdout, \"  0x%03x (%c)\", tmp->b0,(tmp->b0<256 && isprint(tmp->b0))?tmp->b0:'');\n                }\n                if(!(tmp.b1 & 0x8000)) {\n                    if((tmp.b0 & 0x8000))\n                        fprintf(stdout, \"           \");\n                    fprintf(stdout, \"  0x%03x (%c)\", tmp->b1,(tmp->b1<256 && isprint(tmp->b1))?tmp->b1:'');\n                }\n                fprintf(stdout, \"\\n\");\n            }\n        }*/\n        return 0;\n    };\n    \n    function DecodeValue(currentTree) {\n        var len, i,\n            xtreepos=0,\n            X = currentTree[xtreepos],\n            b;\n\n        /* decode one symbol of the data */\n        while(1) {\n            b=readBit();\n            if (debug)\n              util.debug(\"b=\" + b);\n            if(b) {\n                if(!(X.b1 & 0x8000)){\n                \tif (debug)\n                \t  util.debug(\"ret1\");\n                    return X.b1;    /* If leaf node, return data */\n                }\n                X = X.jump;\n                len = currentTree.length;\n                for (i=0;i<len;i++){\n                    if (currentTree[i]===X){\n                        xtreepos=i;\n                        break;\n                    }\n                }\n                //xtreepos++;\n            } else {\n                if(!(X.b0 & 0x8000)){\n                \tif (debug)\n                \t  util.debug(\"ret2\");\n                    return X.b0;    /* If leaf node, return data */\n                }\n                //X++; //??????????????????\n                xtreepos++;\n                X = currentTree[xtreepos];\n            }\n        }\n        if (debug)\n          util.debug(\"ret3\");\n        return -1;\n    };\n    \n    function DeflateLoop() {\n    var last, c, type, i, len;\n\n    do {\n        /*if((last = readBit())){\n            fprintf(errfp, \"Last Block: \");\n        } else {\n            fprintf(errfp, \"Not Last Block: \");\n        }*/\n        last = readBit();\n        type = readBits(2);\n        \n        switch(type) {\n            case 0:\n            \tif (debug)\n            \t    util.debug(\"Stored\");\n                break;\n            case 1:\n            \tif (debug)\n                  util.debug(\"Fixed Huffman codes\");\n                break;\n            case 2:\n            \tif (debug)\n            \t    util.debug(\"Dynamic Huffman codes\");\n                break;\n            case 3:\n            \tif (debug)\n                  util.debug(\"Reserved block type!!\");\n                break;\n            default:\n            \tif (debug)\n                  util.debug(\"Unexpected value \" + type);\n                break;\n        }\n        \n        if(type==0) {\n            var blockLen, cSum;\n\n            // Stored \n            byteAlign();\n            blockLen = readByte();\n            blockLen |= (readByte()<<8);\n\n            cSum = readByte();\n            cSum |= (readByte()<<8);\n\n            if(((blockLen ^ ~cSum) & 0xffff)) {\n              util.debug(\"BlockLen checksum mismatch\");\n            }\n            while(blockLen--) {\n                c = readByte();\n                addBuffer(c);\n            }\n        } else if(type==1) {\n            var j;\n\n            /* Fixed Huffman tables -- fixed decode routine */\n            while(1) {\n            /*\n                256    0000000        0\n                :   :     :\n                279    0010111        23\n                0   00110000    48\n                :    :      :\n                143    10111111    191\n                280 11000000    192\n                :    :      :\n                287 11000111    199\n                144    110010000    400\n                :    :       :\n                255    111111111    511\n    \n                Note the bit order!\n                */\n\n            j = (bitReverse[readBits(7)]>>1);\n            if(j > 23) {\n                j = (j<<1) | readBit();    /* 48..255 */\n\n                if(j > 199) {    /* 200..255 */\n                    j -= 128;    /*  72..127 */\n                    j = (j<<1) | readBit();        /* 144..255 << */\n                } else {        /*  48..199 */\n                    j -= 48;    /*   0..151 */\n                    if(j > 143) {\n                        j = j+136;    /* 280..287 << */\n                        /*   0..143 << */\n                    }\n                }\n            } else {    /*   0..23 */\n                j += 256;    /* 256..279 << */\n            }\n            if(j < 256) {\n                addBuffer(j);\n                //document.write(\"out:\"+String.fromCharCode(j));\n                /*fprintf(errfp, \"@%d %02x\\n\", SIZE, j);*/\n            } else if(j == 256) {\n                /* EOF */\n                break;\n            } else {\n                var len, dist;\n\n                j -= 256 + 1;    /* bytes + EOF */\n                len = readBits(cplext[j]) + cplens[j];\n\n                j = bitReverse[readBits(5)]>>3;\n                if(cpdext[j] > 8) {\n                    dist = readBits(8);\n                    dist |= (readBits(cpdext[j]-8)<<8);\n                } else {\n                    dist = readBits(cpdext[j]);\n                }\n                dist += cpdist[j];\n\n                /*fprintf(errfp, \"@%d (l%02x,d%04x)\\n\", SIZE, len, dist);*/\n                for(j=0;j<len;j++) {\n                    var c = buf32k[(bIdx - dist) & 0x7fff];\n                    addBuffer(c);\n                }\n            }\n            } // while\n        } else if(type==2) {\n            var j, n, literalCodes, distCodes, lenCodes;\n            var ll = new Array(288+32);    // \"static\" just to preserve stack\n    \n            // Dynamic Huffman tables \n    \n            literalCodes = 257 + readBits(5);\n            distCodes = 1 + readBits(5);\n            lenCodes = 4 + readBits(4);\n            //document.write(\"<br>param: \"+literalCodes+\" \"+distCodes+\" \"+lenCodes+\"<br>\");\n            for(j=0; j<19; j++) {\n                ll[j] = 0;\n            }\n    \n            // Get the decode tree code lengths\n    \n            //document.write(\"<br>\");\n            for(j=0; j<lenCodes; j++) {\n                ll[border[j]] = readBits(3);\n                //document.write(ll[border[j]]+\" \");\n            }\n            //fprintf(errfp, \"\\n\");\n            //document.write('<br>ll:'+ll);\n            len = distanceTree.length;\n            for (i=0; i<len; i++)\n                distanceTree[i]=new HufNode();\n            if(CreateTree(distanceTree, 19, ll, 0)) {\n                flushBuffer();\n                return 1;\n            }\n            if (debug){\n              util.debug(\"distanceTree\");\n            \tfor(var a=0;a<distanceTree.length;a++){\n                  util.debug(\"\" + distanceTree[a].b0 + \" \" + distanceTree[a].b1 + \" \" + distanceTree[a].jump + \" \" + distanceTree[a].jumppos);\n                \t/*if (distanceTree[a].jumppos!=-1)\n                    \tdocument.write(\" \"+distanceTree[a].jump.b0+\" \"+distanceTree[a].jump.b1);\n                \t*/\n            \t}\n            }\n            //document.write('<BR>tree created');\n    \n            //read in literal and distance code lengths\n            n = literalCodes + distCodes;\n            i = 0;\n            var z=-1;\n            if (debug)\n              util.debug(\"n=\" + n + \" bits: \" + bits);\n            while(i < n) {\n                z++;\n                j = DecodeValue(distanceTree);\n                if (debug)\n                  util.debug(\"\" + z + \" i:\" + i + \" decode: \" + j + \"    bits\" + bits);\n                if(j<16) {    // length of code in bits (0..15)\n                       ll[i++] = j;\n                } else if(j==16) {    // repeat last length 3 to 6 times \n                       var l;\n                    j = 3 + readBits(2);\n                    if(i+j > n) {\n                        flushBuffer();\n                        return 1;\n                    }\n                    l = i ? ll[i-1] : 0;\n                    while(j--) {\n                        ll[i++] = l;\n                    }\n                } else {\n                    if(j==17) {        // 3 to 10 zero length codes\n                        j = 3 + readBits(3);\n                    } else {        // j == 18: 11 to 138 zero length codes \n                        j = 11 + readBits(7);\n                    }\n                    if(i+j > n) {\n                        flushBuffer();\n                        return 1;\n                    }\n                    while(j--) {\n                        ll[i++] = 0;\n                    }\n                }\n            }\n            /*for(j=0; j<literalCodes+distCodes; j++) {\n                //fprintf(errfp, \"%d \", ll[j]);\n                if ((j&7)==7)\n                    fprintf(errfp, \"\\n\");\n            }\n            fprintf(errfp, \"\\n\");*/\n            // Can overwrite tree decode tree as it is not used anymore\n            len = literalTree.length;\n            for (i=0; i<len; i++)\n                literalTree[i]=new HufNode();\n            if(CreateTree(literalTree, literalCodes, ll, 0)) {\n                flushBuffer();\n                return 1;\n            }\n            len = literalTree.length;\n            for (i=0; i<len; i++)\n                distanceTree[i]=new HufNode();\n            var ll2 = new Array();\n            for (i=literalCodes; i <ll.length; i++){\n                ll2[i-literalCodes]=ll[i];\n            }    \n            if(CreateTree(distanceTree, distCodes, ll2, 0)) {\n                flushBuffer();\n                return 1;\n            }\n            if (debug)\n              util.debug(\"literalTree\");\n            while(1) {\n                j = DecodeValue(literalTree);\n                if(j >= 256) {        // In C64: if carry set\n                    var len, dist;\n                    j -= 256;\n                    if(j == 0) {\n                        // EOF\n                        break;\n                    }\n                    j--;\n                    len = readBits(cplext[j]) + cplens[j];\n    \n                    j = DecodeValue(distanceTree);\n                    if(cpdext[j] > 8) {\n                        dist = readBits(8);\n                        dist |= (readBits(cpdext[j]-8)<<8);\n                    } else {\n                        dist = readBits(cpdext[j]);\n                    }\n                    dist += cpdist[j];\n                    while(len--) {\n                        var c = buf32k[(bIdx - dist) & 0x7fff];\n                        addBuffer(c);\n                    }\n                } else {\n                    addBuffer(j);\n                }\n            }\n        }\n    } while(!last);\n    flushBuffer();\n\n    byteAlign();\n    return 0;\n};\n\nZlib.Unzip.prototype.unzipFile = function(name) {\n    var i;\n\tthis.unzip();\n\t//alert(unzipped[0][1]);\n\tfor (i=0;i<unzipped.length;i++){\n\t\tif(unzipped[i][1]==name) {\n\t\t\treturn unzipped[i][0];\n\t\t}\n\t}\n\t\n  };\n    \n    \nZlib.Unzip.prototype.unzip = function() {\n\t//convertToByteArray(input);\n\tif (debug)\n\t  util.debug(bA);\n\t/*for (i=0;i<bA.length*8;i++){\n\t\tdocument.write(readBit());\n\t\tif ((i+1)%8==0)\n\t\t\tdocument.write(\" \");\n\t}*/\n\t/*for (i=0;i<bA.length;i++){\n\t\tdocument.write(readByte()+\" \");\n\t\tif ((i+1)%8==0)\n\t\t\tdocument.write(\" \");\n\t}\n\tfor (i=0;i<bA.length;i++){\n\t\tdocument.write(bA[i]+\" \");\n\t\tif ((i+1)%16==0)\n\t\t\tdocument.write(\"<br>\");\n\t}\t\n\t*/\n\t//alert(bA);\n\tnextFile();\n\treturn unzipped;\n  };\n    \n function nextFile(){\n \tif (debug)\n \t  util.debug(\"NEXTFILE\");\n \toutputArr = [];\n \tvar tmp = [];\n \tmodeZIP = false;\n\ttmp[0] = readByte();\n\ttmp[1] = readByte();\n\t\n\tif (debug)\n\t  util.debug(\"type: \" + tmp[0] + \" \" + tmp[1]);\n\tif (tmp[0] == parseInt(\"78\",16) && (tmp[1] == parseInt(\"156\",10) || tmp[1] == parseInt(\"1\", 10))){ //GZIP\n\t\tif (debug)\n\t\t  util.debug(\"GEONExT-GZIP\");\n\t\tDeflateLoop();\n\t\tif (debug)\n\t    util.debug(outputArr.join(''));\n    // unzipped[files] = new Array(2);\n    \tunzipped[files] = outputArr.join('');\n    \tfiles++;\n\t}\n\tif (tmp[0] == parseInt(\"1f\",16) && tmp[1] == parseInt(\"8b\",16)){ //GZIP\n\t\tif (debug)\n      util.debug(\"GZIP\");\n\t\t//DeflateLoop();\n\t\tskipdir();\n\t\tif (debug)\n      util.debug(outputArr.join(''));\n\t\tunzipped[files] = new Array(2);\n    \tunzipped[files][0] = outputArr.join('');\n    \tunzipped[files][1] = \"file\";\n    \tfiles++;\n\t}\n\tif (tmp[0] == parseInt(\"50\",16) && tmp[1] == parseInt(\"4b\",16)){ //ZIP\n\t\tmodeZIP = true;\n\t\ttmp[2] = readByte();\n\t\ttmp[3] = readByte();\n\t\tif (tmp[2] == parseInt(\"3\",16) && tmp[3] == parseInt(\"4\",16)){\n\t\t\t//MODE_ZIP\n\t\t\ttmp[0] = readByte();\n\t\t\ttmp[1] = readByte();\n\t\t\tif (debug)\n        util.debug(\"ZIP-Version: \"+tmp[1]+\" \"+tmp[0]/10+\".\"+tmp[0]%10);\n\t\t\t\n\t\t\tgpflags = readByte();\n\t\t\tgpflags |= (readByte()<<8);\n\t\t\tif (debug)\n        util.debug(\"gpflags: \"+gpflags);\n\t\t\t\n\t\t\tvar method = readByte();\n\t\t\tmethod |= (readByte()<<8);\n\t\t\tif (debug)\n        util.debug(\"method: \"+method);\n\t\t\t\n\t\t\treadByte();\n\t\t\treadByte();\n\t\t\treadByte();\n\t\t\treadByte();\n\t\t\t\n\t\t\tvar crc = readByte();\n\t\t\tcrc |= (readByte()<<8);\n\t\t\tcrc |= (readByte()<<16);\n\t\t\tcrc |= (readByte()<<24);\n\t\t\t\n\t\t\tvar compSize = readByte();\n\t\t\tcompSize |= (readByte()<<8);\n\t\t\tcompSize |= (readByte()<<16);\n\t\t\tcompSize |= (readByte()<<24);\n\t\t\t\n\t\t\tvar size = readByte();\n\t\t\tsize |= (readByte()<<8);\n\t\t\tsize |= (readByte()<<16);\n\t\t\tsize |= (readByte()<<24);\n\t\t\t\n\t\t\tif (debug)\n\t\t\t  util.debug(\"local CRC: \"+crc+\"\\nlocal Size: \"+size+\"\\nlocal CompSize: \"+compSize);\n\t\t\t\n\t\t\tvar filelen = readByte();\n\t\t\tfilelen |= (readByte()<<8);\n\t\t\t\n\t\t\tvar extralen = readByte();\n\t\t\textralen |= (readByte()<<8);\n\t\t\t\n\t\t\tif (debug)\n\t\t\t  util.debug(\"filelen \"+filelen);\n\t\t\ti = 0;\n\t\t\tnameBuf = [];\n\t\t\twhile (filelen--){ \n\t\t\t\tvar c = readByte();\n\t\t\t\tif (c == \"/\" | c ==\":\"){\n\t\t\t\t\ti = 0;\n\t\t\t\t} else if (i < NAMEMAX-1)\n\t\t\t\t\tnameBuf[i++] = String.fromCharCode(c);\n\t\t\t}\n\t\t\tif (debug)\n\t\t\t  util.debug(\"nameBuf: \"+nameBuf);\n\t\t\t\n\t\t\t//nameBuf[i] = \"\\0\";\n\t\t\tif (!fileout)\n\t\t\t\tfileout = nameBuf;\n\t\t\t\n\t\t\tvar i = 0;\n\t\t\twhile (i < extralen){\n\t\t\t\tc = readByte();\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t\t\n\t\t\tCRC = 0xffffffff;\n\t\t\tSIZE = 0;\n\t\t\t\n\t\t\tif (size = 0 && fileOut.charAt(fileout.length-1)==\"/\"){\n\t\t\t\t//skipdir\n\t\t\t\tif (debug)\n\t\t\t\t  util.debug(\"skipdir\");\n\t\t\t}\n\t\t\tif (method == 8){\n\t\t\t\tDeflateLoop();\n\t\t\t\tif (debug)\n\t\t\t\t  util.debug(outputArr.join(''));\n\t\t\t\tunzipped[files] = new Array(2);\n\t\t\t\tunzipped[files][0] = outputArr.join('');\n    \t\t\tunzipped[files][1] = nameBuf.join('');\n    \t\t\tfiles++;\n\t\t\t\t//return outputArr.join('');\n\t\t\t}\n\t\t\tskipdir();\n\t\t}\n\t}\n };\n\t\nfunction skipdir(){\n    var crc, \n        tmp = [],\n        compSize, size, os, i, c;\n    \n\tif ((gpflags & 8)) {\n\t\ttmp[0] = readByte();\n\t\ttmp[1] = readByte();\n\t\ttmp[2] = readByte();\n\t\ttmp[3] = readByte();\n\t\t\n\t\tif (tmp[0] == parseInt(\"50\",16) && \n            tmp[1] == parseInt(\"4b\",16) && \n            tmp[2] == parseInt(\"07\",16) && \n            tmp[3] == parseInt(\"08\",16))\n        {\n            crc = readByte();\n            crc |= (readByte()<<8);\n            crc |= (readByte()<<16);\n            crc |= (readByte()<<24);\n\t\t} else {\n\t\t\tcrc = tmp[0] | (tmp[1]<<8) | (tmp[2]<<16) | (tmp[3]<<24);\n\t\t}\n\t\t\n\t\tcompSize = readByte();\n\t\tcompSize |= (readByte()<<8);\n\t\tcompSize |= (readByte()<<16);\n\t\tcompSize |= (readByte()<<24);\n\t\t\n\t\tsize = readByte();\n\t\tsize |= (readByte()<<8);\n\t\tsize |= (readByte()<<16);\n\t\tsize |= (readByte()<<24);\n\t\t\n\t\tif (debug)\n\t\t  util.debug(\"CRC:\");\n\t}\n\n\tif (modeZIP)\n\t\tnextFile();\n\t\n\ttmp[0] = readByte();\n\tif (tmp[0] != 8) {\n\t\tif (debug)\n\t\t  util.debug(\"Unknown compression method!\");\n        return 0;\t\n\t}\n\t\n\tgpflags = readByte();\n\tif (debug){\n\t\tif ((gpflags & ~(parseInt(\"1f\",16))))\n\t\t  util.debug(\"Unknown flags set!\");\n\t}\n\t\n\treadByte();\n\treadByte();\n\treadByte();\n\treadByte();\n\t\n\treadByte();\n\tos = readByte();\n\t\n\tif ((gpflags & 4)){\n\t\ttmp[0] = readByte();\n\t\ttmp[2] = readByte();\n\t\tlen = tmp[0] + 256*tmp[1];\n\t\tif (debug)\n\t\t  util.debug(\"Extra field size: \"+len);\n\t\tfor (i=0;i<len;i++)\n\t\t\treadByte();\n\t}\n\t\n\tif ((gpflags & 8)){\n\t\ti=0;\n\t\tnameBuf=[];\n\t\twhile (c=readByte()){\n\t\t\tif(c == \"7\" || c == \":\")\n\t\t\t\ti=0;\n\t\t\tif (i<NAMEMAX-1)\n\t\t\t\tnameBuf[i++] = c;\n\t\t}\n\t\t//nameBuf[i] = \"\\0\";\n\t\tif (debug)\n\t\t  util.debug(\"original file name: \"+nameBuf);\n\t}\n\t\t\n\tif ((gpflags & 16)){\n\t\twhile (c=readByte()){\n\t\t\t//FILE COMMENT\n\t\t}\n\t}\n\t\n\tif ((gpflags & 2)){\n\t\treadByte();\n\t\treadByte();\n\t}\n\t\n\tDeflateLoop();\n\t\n\tcrc = readByte();\n\tcrc |= (readByte()<<8);\n\tcrc |= (readByte()<<16);\n\tcrc |= (readByte()<<24);\n\t\n\tsize = readByte();\n\tsize |= (readByte()<<8);\n\tsize |= (readByte()<<16);\n\tsize |= (readByte()<<24);\n\t\n\tif (modeZIP)\n\t\tnextFile();\n\t\n};\n\n};\n\n/**\n*  Base64 encoding / decoding\n*  @see <a href=\"http://www.webtoolkit.info/\">http://www.webtoolkit.info/</A>\n*/\nZlib.Base64 = {\n\n    // private property\n    _keyStr : \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n\n    // public method for encoding\n    encode : function (input) {\n        var output = [],\n            chr1, chr2, chr3, enc1, enc2, enc3, enc4,\n            i = 0;\n\n        input = Zlib.Base64._utf8_encode(input);\n\n        while (i < input.length) {\n\n            chr1 = input.charCodeAt(i++);\n            chr2 = input.charCodeAt(i++);\n            chr3 = input.charCodeAt(i++);\n\n            enc1 = chr1 >> 2;\n            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n            enc4 = chr3 & 63;\n\n            if (isNaN(chr2)) {\n                enc3 = enc4 = 64;\n            } else if (isNaN(chr3)) {\n                enc4 = 64;\n            }\n\n            output.push([this._keyStr.charAt(enc1),\n                         this._keyStr.charAt(enc2),\n                         this._keyStr.charAt(enc3),\n                         this._keyStr.charAt(enc4)].join(''));\n        }\n\n        return output.join('');\n    },\n\n    // public method for decoding\n    decode : function (input, utf8) {\n        var output = [],\n            chr1, chr2, chr3,\n            enc1, enc2, enc3, enc4,\n            i = 0;\n\n        input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n        while (i < input.length) {\n\n            enc1 = this._keyStr.indexOf(input.charAt(i++));\n            enc2 = this._keyStr.indexOf(input.charAt(i++));\n            enc3 = this._keyStr.indexOf(input.charAt(i++));\n            enc4 = this._keyStr.indexOf(input.charAt(i++));\n\n            chr1 = (enc1 << 2) | (enc2 >> 4);\n            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n            chr3 = ((enc3 & 3) << 6) | enc4;\n\n            output.push(String.fromCharCode(chr1));\n\n            if (enc3 != 64) {\n                output.push(String.fromCharCode(chr2));\n            }\n            if (enc4 != 64) {\n                output.push(String.fromCharCode(chr3));\n            }\n        }\n        \n        output = output.join(''); \n        \n        if (utf8) {\n            output = Zlib.Base64._utf8_decode(output);\n        }\n        return output;\n\n    },\n\n    // private method for UTF-8 encoding\n    _utf8_encode : function (string) {\n        string = string.replace(/\\r\\n/g,\"\\n\");\n        var utftext = \"\";\n\n        for (var n = 0; n < string.length; n++) {\n\n            var c = string.charCodeAt(n);\n\n            if (c < 128) {\n                utftext += String.fromCharCode(c);\n            }\n            else if((c > 127) && (c < 2048)) {\n                utftext += String.fromCharCode((c >> 6) | 192);\n                utftext += String.fromCharCode((c & 63) | 128);\n            }\n            else {\n                utftext += String.fromCharCode((c >> 12) | 224);\n                utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n                utftext += String.fromCharCode((c & 63) | 128);\n            }\n\n        }\n\n        return utftext;\n    },\n\n    // private method for UTF-8 decoding\n    _utf8_decode : function (utftext) {\n        var string = [],\n            i = 0,\n            c = 0, c2 = 0, c3 = 0;\n\n        while ( i < utftext.length ) {\n            c = utftext.charCodeAt(i);\n            if (c < 128) {\n                string.push(String.fromCharCode(c));\n                i++;\n            }\n            else if((c > 191) && (c < 224)) {\n                c2 = utftext.charCodeAt(i+1);\n                string.push(String.fromCharCode(((c & 31) << 6) | (c2 & 63)));\n                i += 2;\n            }\n            else {\n                c2 = utftext.charCodeAt(i+1);\n                c3 = utftext.charCodeAt(i+2);\n                string.push(String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));\n                i += 3;\n            }\n        }\n        return string.join('');\n    },\n    \n    _destrip: function (stripped, wrap){\n        var lines = [], lineno, i,\n            destripped = [];\n        \n        if (wrap==null) \n            wrap = 76;\n            \n        stripped.replace(/ /g, \"\");\n        lineno = stripped.length / wrap;\n        for (i = 0; i < lineno; i++)\n            lines[i]=stripped.substr(i * wrap, wrap);\n        if (lineno != stripped.length / wrap)\n            lines[lines.length]=stripped.substr(lineno * wrap, stripped.length-(lineno * wrap));\n            \n        for (i = 0; i < lines.length; i++)\n            destripped.push(lines[i]);\n        return destripped.join('\\n');\n    },\n    \n    decodeAsArray: function (input){\n        var dec = this.decode(input),\n            ar = [], i;\n        for (i=0;i<dec.length;i++){\n            ar[i]=dec.charCodeAt(i);\n        }\n        return ar;\n    },\n    \n    decodeGEONExT : function (input) {\n        return decodeAsArray(destrip(input),false);\n    }\n};\n\n/**\n * @private\n */\nZlib.asciiCharCodeAt = function(str,i){\n\tvar c = str.charCodeAt(i);\n\tif (c>255){\n    \tswitch (c) {\n\t\t\tcase 8364: c=128;\n\t    \tbreak;\n\t    \tcase 8218: c=130;\n\t    \tbreak;\n\t    \tcase 402: c=131;\n\t    \tbreak;\n\t    \tcase 8222: c=132;\n\t    \tbreak;\n\t    \tcase 8230: c=133;\n\t    \tbreak;\n\t    \tcase 8224: c=134;\n\t    \tbreak;\n\t    \tcase 8225: c=135;\n\t    \tbreak;\n\t    \tcase 710: c=136;\n\t    \tbreak;\n\t    \tcase 8240: c=137;\n\t    \tbreak;\n\t    \tcase 352: c=138;\n\t    \tbreak;\n\t    \tcase 8249: c=139;\n\t    \tbreak;\n\t    \tcase 338: c=140;\n\t    \tbreak;\n\t    \tcase 381: c=142;\n\t    \tbreak;\n\t    \tcase 8216: c=145;\n\t    \tbreak;\n\t    \tcase 8217: c=146;\n\t    \tbreak;\n\t    \tcase 8220: c=147;\n\t    \tbreak;\n\t    \tcase 8221: c=148;\n\t    \tbreak;\n\t    \tcase 8226: c=149;\n\t    \tbreak;\n\t    \tcase 8211: c=150;\n\t    \tbreak;\n\t    \tcase 8212: c=151;\n\t    \tbreak;\n\t    \tcase 732: c=152;\n\t    \tbreak;\n\t    \tcase 8482: c=153;\n\t    \tbreak;\n\t    \tcase 353: c=154;\n\t    \tbreak;\n\t    \tcase 8250: c=155;\n\t    \tbreak;\n\t    \tcase 339: c=156;\n\t    \tbreak;\n\t    \tcase 382: c=158;\n\t    \tbreak;\n\t    \tcase 376: c=159;\n\t    \tbreak;\n\t    \tdefault:\n\t    \tbreak;\n\t    }\n\t}\n\treturn c;\n};\n\n/**\n * Decoding string into utf-8\n * @param {String} string to decode\n * @return {String} utf8 decoded string\n */\nZlib.utf8Decode = function(utftext) {\n  var string = [];\n  var i = 0;\n  var c = 0, c1 = 0, c2 = 0;\n\n  while ( i < utftext.length ) {\n    c = utftext.charCodeAt(i);\n\n    if (c < 128) {\n      string.push(String.fromCharCode(c));\n      i++;\n    } else if((c > 191) && (c < 224)) {\n      c2 = utftext.charCodeAt(i+1);\n      string.push(String.fromCharCode(((c & 31) << 6) | (c2 & 63)));\n      i += 2;\n    } else {\n      c2 = utftext.charCodeAt(i+1);\n      c3 = utftext.charCodeAt(i+2);\n      string.push(String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));\n      i += 3;\n    }\n  };\n  return string.join('');\n};","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/raw_object.js":"var crypto = require('crypto'),\n  util = require('util'),\n  Buffer = require('buffer').Buffer,\n  BinaryParser = require('./binary_parser').BinaryParser;\n\nvar RawObject = exports.RawObject = function(type, content) {\n  var _type = type, _content = content;\n  \n  Object.defineProperty(this, \"type\", { get: function() { return _type; }, set: function(value) { _type = value; }, enumerable: true});    \n  Object.defineProperty(this, \"content\", { get: function() { return _content; }, set: function(value) { _content = value; }, enumerable: true});      \n}\n\nRawObject.prototype.sha1 = function(encoding) {\n  type = type ? type : 'binary';  \n  // Create the basis for the digest\n  var digest_content = this.type + \" \" + this.content.length + BinaryParser.fromByte(0) + this.content;\n  // Use node crypto library to create sha1 hash\n  var hash = crypto.createHash(\"sha1\");\n  hash.update(digest_content);\n  // Return the hash digest\n  return hash.digest('binary');\n}\n\nRawObject.prototype.sha1_hex = function() {\n  this.sha1('hex');\n}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/pack_storage.js":"var util = require('util'),\n  fs = require('fs'),\n  Buffer = require('buffer').Buffer,\n  BinaryParser = require('./binary_parser').BinaryParser,\n  FileWindow = require('./file_window').FileWindow,\n  RawObject = require('./raw_object').RawObject;\n  Zlib = require('../zlib/zlib').Zlib;\n  \nvar PACK_IDX_SIGNATURE = '\\xfftOc';\nvar FAN_OUT_COUNT = 256;\nvar IDX_OFFSET_SIZE = 4;\nvar OFFSET_SIZE = 4;\nvar OFFSET_START = FAN_OUT_COUNT * IDX_OFFSET_SIZE;\nvar SHA1_SIZE = 20;\nvar CRC_SIZE = 4;\nvar SHA1_START = OFFSET_START + OFFSET_SIZE;\nvar ENTRY_SIZE = OFFSET_SIZE + SHA1_SIZE;\nvar ENTRY_SIZE_V2 = SHA1_SIZE + CRC_SIZE + OFFSET_SIZE;\n\n// Default types\nvar OBJ_NONE = 0;\nvar OBJ_COMMIT = 1;\nvar OBJ_TREE = 2;\nvar OBJ_BLOB = 3;\nvar OBJ_TAG = 4;\nvar OBJ_OFS_DELTA = 6;\nvar OBJ_REF_DELTA = 7;\nvar OBJ_TYPES = [null, \"commit\", \"tree\", \"blob\", \"tag\"];\n\nvar PackStorage = exports.PackStorage = function(file) {\n  var _name = file, _cache = {}, _version = null, _offsets = null, _size = 0;\n  // Replace idx reference with pack\n  if(file.match(/\\.idx$/)) {\n    file = file.substr(0, file.length - 3) + \"pack\";\n  }\n  \n  Object.defineProperty(this, \"name\", { get: function() { return _name; }, set: function(value) { _name = value; }, enumerable: true});        \n  Object.defineProperty(this, \"cache\", { get: function() { return _cache; }, set: function(value) { _cache = value; }, enumerable: true});        \n  Object.defineProperty(this, \"version\", { get: function() { return _version; }, set: function(value) { _version = value; }, enumerable: true});        \n  Object.defineProperty(this, \"offsets\", { get: function() { return _offsets; }, set: function(value) { _offsets = value; }, enumerable: true});        \n  Object.defineProperty(this, \"size\", { get: function() { return _size; }, set: function(value) { _size = value; }, enumerable: true});        \n  // Initialize pack\n  init_pack(this);\n}\n\n// Search for a sha1 in the pack\nPackStorage.prototype.find = function(sha1) {\n  // If we have the object in the cache return it\n  if(this.cache[sha1]) return this.cache[sha1];\n  // We need to search for the object in the pack file\n  var offset = find_object(this, sha1);  \n  // If no object found return null\n  if(!offset) return null;\n  // Parse the object at the located offset\n  var obj = this.parse_object(this, offset);\n  this.cache[sha1] = obj;\n  return obj;\n}\n\n// Close the pack (nothing should be open, might be able to remove this TODO)\nPackStorage.prototype.close = function() {  \n}\n\nPackStorage.prototype.parse_object = function(pack, offset) {  \n  // Open the pack file\n  var packfile = fs.openSync(pack.name, \"r\");\n  var result = this.unpack_object(pack, packfile, offset);\n  var data = result[0];\n  var type = result[1];\n  // Close the packfile\n  fs.closeSync(packfile)\n  return new RawObject(OBJ_TYPES[type], data);\n}\n\nPackStorage.prototype.unpack_object = function(pack, packfile, offset, options) {\n  // Ensure valid options variable\n  options = options ? options : {};\n  var obj_offset = offset;\n  \n  // TODO TODO TODO TODO TODO TODO\n  // TODO TODO TODO TODO TODO TODO\n  // TODO TODO TODO TODO TODO TODO\n  \n  var buf = new Buffer(1);\n  fs.readSync(packfile, buf, 0, 1, offset);\n  // Fetch the first byte\n  var c = buf[0];  \n  var size = c & 0xf\n  var type = (c >> 4) & 7;\n  var shift = 4;\n  var offset = offset + 1;\n  // unpack until we have decoded size\n  while((c & 0x80) != 0) {\n    fs.readSync(packfile, buf, 0, 1, offset);\n    c = buf[0];\n    // Adjust size for the byte\n    size = size | ((c & 0x7f) << shift);\n    shift = shift + 7;\n    offset = offset + 1;\n  }\n  \n  // If it's not a commit or tree and caching is enabled then return false\n  if(!(type == OBJ_COMMIT || type == OBJ_TREE) && options['caching']) return [false, false];\n  // Check the type of object and either unpack the delta or the compressed data (gziped)\n  if(type == OBJ_OFS_DELTA || type == OBJ_REF_DELTA) {\n    return this.unpack_deltified(packfile, type, offset, obj_offset, size, options);\n  } else if(type == OBJ_COMMIT || type == OBJ_TREE || type == OBJ_BLOB || type == OBJ_TAG) {\n    var data = unpack_compressed(pack, offset, size);\n    return [data, type];\n  } else {\n    throw new \"invalid type \" + type;\n  }  \n}\n\nPackStorage.prototype.unpack_deltified = function(packfile, type, offset, obj_offset, size, options) {\n  var data = new Buffer(SHA1_SIZE);\n  // Read the SHA\n  fs.readSync(packfile, data, 0, SHA1_SIZE, offset);\n  \n  if(type == OBJ_OFS_DELTA) {\n    var i = 0;\n    var c = data[i];\n    var base_offset = c & 0x7f;\n    \n    while((c & 0x80) != 0) {\n      c = data[++i];\n      base_offset = base_offset + 1;\n      base_offset = base_offset << 7;\n      base_offset = base_offset | (c & 0x7f);\n    }\n    \n    base_offset = obj_offset - base_offset;\n    offset = offset + i + 1;\n  } else {\n    base_offset = find_object(this, data.toString())\n    offset = offset + SHA1_SIZE;\n  }\n  \n  // Fetch the object at this offset and unpack the result\n  var object_array = this.unpack_object(this, packfile, base_offset);\n  var base = object_array[0];\n  var type = object_array[1];\n  // If it's not a Commit or Tree return an empty delta\n  if(!(type == OBJ_COMMIT || type == OBJ_TREE) && options['caching']) return [false, false];\n  // Unpack the the data\n  var delta = unpack_compressed(this, offset, size);\n  var delta2 = patch_delta(base, delta);\n  return [delta2, type];\n}\n\nvar to_hex_string = function(string) {\n  var hexString = '';\n  for(var index = 0; index < string.length; index++) {\n    var value = BinaryParser.toByte(string.substr(index, 1));\n    var number = value <= 15 ? \"0\" + value.toString(16) : value.toString(16);\n    hexString = hexString + number;\n  }\n  return hexString;\n};\n\nvar patch_delta = function(base, delta) {\n  var delta_header_parts = patch_delta_header_size(delta, 0);\n  var src_size = delta_header_parts[0];\n  var pos = delta_header_parts[1];\n  \n  if(src_size != base.length) throw \"invalid delta data\";\n    \n  delta_header_parts = patch_delta_header_size(delta, pos);\n  var dest_size = delta_header_parts[0];\n  pos = delta_header_parts[1];\n  var dest = '';\n  \n  while(pos < delta.length) {\n    var c = delta.charCodeAt(pos);\n    pos = pos + 1;\n    \n    // Keep reading until end of data pack\n    if((c & 0x80) != 0) {\n      pos = pos - 1;\n      var cp_off = 0;\n      var cp_size = 0;\n      \n      if((c & 0x01) != 0) cp_off = delta.charCodeAt(pos += 1);\n      if((c & 0x02) != 0) cp_off = cp_off | (delta.charCodeAt(pos += 1) << 8);\n      if((c & 0x04) != 0) cp_off = cp_off | (delta.charCodeAt(pos += 1) << 16);\n      if((c & 0x08) != 0) cp_off = cp_off | (delta.charCodeAt(pos += 1) << 24);\n      \n      if((c & 0x10) != 0) cp_size = delta.charCodeAt(pos += 1);\n      if((c & 0x20) != 0) cp_size = cp_size | (delta.charCodeAt(pos += 1) << 8);\n      if((c & 0x40) != 0) cp_size = cp_size | (delta.charCodeAt(pos += 1) << 16);\n      if(cp_size == 0) cp_size = 0x10000;\n      \n      pos = pos + 1;\n      dest = dest + base.substr(cp_off, cp_size);\n    } else if(c != 0) {\n      dest = dest + delta.substr(pos, c);\n      pos = pos + c;\n    } else {\n      throw \"invalid delta data\";\n    }\n  }\n  \n  return dest;\n}\n\nvar patch_delta_header_size = function(delta, pos) {\n  var size = 0;\n  var shift = 0;\n\n  do {\n    var c = delta.charCodeAt(pos);\n    if(c == null) throw 'invalid delta data';\n    pos = pos + 1;\n    size = size | ((c & 0x7f) << shift);\n    shift = shift + 7\n    \n  } while((c & 0x80) != 0);\n  \n  // Return the header size and position\n  return [size, pos];\n}\n\nvar unpack_compressed = function(pack, offset, destsize) {\n  var outdata = \"\";\n  var file_offset = offset;\n  var packfile = fs.openSync(pack.name, \"r\");\n\n  // Read in the compressed object (this could be huge :() \n  // TODO TODO TODO, change unzip method to allow for initializing the structure and then decoding \n  // pieces\n  var indata = new Buffer(destsize + 100);\n  var bytes_read = fs.readSync(packfile, indata, 0, destsize + 100, file_offset);\n  // Close the file\n  fs.closeSync(packfile);\n  // Adjust the file_offset\n  file_offset = file_offset + destsize;  \n  outdata = outdata + new Zlib.Unzip(indata).unzip();\n\n  if(outdata.size > destsize) {    \n    throw \"error reading pack data\";\n  }\n  // Return the data read from the compressed block\n  return outdata;\n}\n\nvar find_object_in_index = function(pack, idx, sha1) {\n  // Parse the first value of the sha as an index\n  var slot = sha1.charCodeAt(0);\n  if(slot == NaN) return null;\n  \n  // Unpack the variables\n  var first = pack.offsets[slot];\n  var last = pack.offsets[slot + 1];\n  \n  while(first < last) {\n    var mid = parseInt((first + last) / 2);    \n    // If we have a version 2 pack file\n    if(pack.version == 2) {\n      // Fetch the sha1\n      var midsha1 = idx.index([(OFFSET_START + (mid * SHA1_SIZE)), SHA1_SIZE]);      \n      var compare_sha1 = '';\n      // Convert midsha1 to allow for correct string comparision\n      for(var i = 0; i < midsha1.length; i++) {\n        compare_sha1 = compare_sha1 + String.fromCharCode(midsha1[i]);\n      }\n\n      // Do a locale Compare\n      var cmp = compare_sha1.localeCompare(sha1);\n      if(cmp < 0) {\n        first = mid + 1;        \n      } else if(cmp > 0) {\n        last = mid;\n      } else {\n        var pos = OFFSET_START + (pack.size * (SHA1_SIZE + CRC_SIZE)) + (mid * OFFSET_SIZE);\n        var offset = idx.index([pos, OFFSET_SIZE]);\n        offset = BinaryParser.toInt(reverse_buffer(offset).toString('binary', 0, 4));\n        return offset;\n      }\n    } else {\n      var midsha1 = idx.index([SHA1_START + mid * ENTRY_SIZE, SHA1_SIZE]);\n      var compare_sha1 = '';\n      // Convert midsha1 to allow for correct string comparision\n      for(var i = 0; i < midsha1.length; i++) {\n        compare_sha1 = compare_sha1 + String.fromCharCode(midsha1[i]);\n      }\n\n      // Do a locale Compare\n      var cmp = compare_sha1.localeCompare(sha1);\n      if(cmp < 0) {\n        first = mid + 1;        \n      } else if(cmp > 0) {\n        last = mid;\n      } else {\n        var pos = OFFSET_START + mid * ENTRY_SIZE;\n        var offset = idx.index([pos, OFFSET_SIZE]);\n        offset = BinaryParser.toInt(reverse_buffer(offset).toString('binary', 0, 4));\n        return offset;\n      }      \n    }    \n  }  \n  return null;\n}\n\nvar find_object = function(pack, sha1) {\n  var obj = null;\n  // Should I not use the cached version in the future ? TODO\n  with_idx(pack, function(err, idx) {    \n    obj = find_object_in_index(pack, idx, sha1);\n  })\n  \n  return obj;\n}\n\nvar reverse_buffer = function(buffer) {\n  var result_buffer = new Buffer(buffer.length);\n  var length = buffer.length;\n  \n  for(var i = 0; i < length; i++) {\n    result_buffer[length - 1 - i] = buffer[i];\n  }\n  \n  return result_buffer;\n}\n\nvar init_pack = function(pack) {  \n  // TODO TODO TODO\n  with_idx(pack, function(err, idx) {\n    // Reset pack offsets\n    pack.offsets = [0];\n    // Do a max of FAN_OUT_COUNT to avoid going crazy\n    for(var i = 0; i < FAN_OUT_COUNT; i++) {\n      // Each offset value is a 4 byte network encoded integer\n      var pos = idx.index([i * IDX_OFFSET_SIZE, IDX_OFFSET_SIZE])      \n      pos = BinaryParser.toInt(reverse_buffer(pos).toString('binary', 0, 4));\n      // If the position is less than the pack offset stored the pack index is corrupt\n      if(pos < pack.offsets[i]) {        \n        throw \"pack \" + pack.name + \" has discontinuous index \" + i;\n      }\n      // Add offset position to list of tracked offsets\n      pack.offsets.push(pos);\n    }\n    // Adjust the pack size\n    pack.size = pack.offsets[pack.offsets.length - 1];\n    // Close all files\n    idx.close();\n  });\n}\n\nvar with_idx = function(pack, index_file, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  index_file = args.length ? args.shift() : null;\n  // Final idx file name\n  var idx_file_name = null;\n  // Define file handle variable\n  var idxfile = null;\n  \n  if(!index_file) {\n    index_file = pack.name;\n    idx_file_name = pack.name.substr(0, pack.name.length - 4) + \"idx\";\n    idxfile = fs.openSync(pack.name.substr(0, pack.name.length - 4) + \"idx\", \"r\");\n  } else {\n    idx_file_name = index_file;\n    idxfile = fs.openSync(index_file, \"r\");\n  }\n  \n  // Read header\n  var sign_buffer = new Buffer(4);\n  var signature = '';\n  fs.readSync(idxfile, sign_buffer, 0, 4);\n  for(var i = 0; i < sign_buffer.length;  i++) {\n    signature = signature + BinaryParser.fromByte(sign_buffer[i]);\n  }\n  \n  // Extract version of pack\n  var ver_buffer = new Buffer(4);\n  fs.readSync(idxfile, ver_buffer, 0, 4);\n  var ver = BinaryParser.toInt(reverse_buffer(ver_buffer).toString('binary', 0, 4));\n  // Close idx file\n  fs.closeSync(idxfile);  \n  // If we have a IDX pack signature this is at least version 2 of the file format\n  if(signature == PACK_IDX_SIGNATURE) {\n    if(ver != 2) {\n      throw (\"pack \" + pack.name + \" has unknown pack file version \" + ver);\n    }\n    pack.version = 2;\n  } else {\n    pack.version = 1;\n  }\n  // Create a file window and return it\n  var idx = new FileWindow(idx_file_name, pack.version);\n  callback(null, idx);\n}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/diff/diff.js":"var util = require('util'),\n  SequenceCallbacks = require('./callbacks').SequenceCallbacks,\n  ContextChange = require('./change').ContextChange,\n  Change = require('./change').Change,\n  DiffCallbacks = require('./callbacks').DiffCallbacks,\n  SDiffCallbacks = require('./callbacks').SDiffCallbacks,\n  BalancedCallbacks = require('./callbacks').BalancedCallbacks,\n  ContextDiffCallbacks = require('./callbacks').ContextDiffCallbacks,\n  Hunk = require('./hunk').Hunk;\n\nvar Difference = exports.Difference = function() {  \n}\n\nDifference.LCS = function() {  \n}\n\n// Scope the Sequence Callbacks class\nDifference.LCS.SequenceCallbacks = SequenceCallbacks;\nDifference.LCS.ContextChange = ContextChange;\nDifference.LCS.DiffCallbacks = DiffCallbacks;\nDifference.LCS.SDiffCallbacks = SDiffCallbacks;\nDifference.LCS.BalancedCallbacks = BalancedCallbacks;\nDifference.LCS.ContextDiffCallbacks = ContextDiffCallbacks;\nDifference.LCS.Change = Change;\nDifference.LCS.Hunk = Hunk;\n\n// Diff::LCS.sdiff computes all necessary components to show two sequences\n// and their minimized differences side by side, just like the Unix\n// utility <em>sdiff</em> does:\n//\n//     old        <     -\n//     same             same\n//     before     |     after\n//     -          >     new\n//\n// See Diff::LCS::SDiffCallbacks for the default behaviour. An alternate\n// behaviour may be implemented with Diff::LCS::ContextDiffCallbacks. If\n// a Class argument is provided for +callbacks+, //diff will attempt to\n// initialise it. If the +callbacks+ object (possibly initialised)\n// responds to //finish, it will be called.\nDifference.LCS.sdiff = function(seq1, seq2, callbacks, block) {\n  callbacks = callbacks != null ? callbacks : Difference.LCS.SDiffCallbacks;\n  \n  if(Object.prototype.toString.call(callbacks) == \"[object Function]\") {\n    callbacks = new callbacks();\n  }\n  \n  // Traverse the sequence\n  Difference.LCS.traverse_balanced(seq1, seq2, callbacks);  \n  if(callbacks.finish != null) callbacks.finish();\n  \n  if(block != null) {    \n    var res = callbacks.diffs.map(function(hunk) {\n      if(Array.isArray(hunk)) {\n        hunk = hunk.map(function(v) { return block(v); });\n      } else {\n        block(hunk);\n      }\n    });\n    \n    return res;\n  } else {    \n    return callbacks.diffs;\n  }  \n}\n\n// Diff::LCS.diff computes the smallest set of additions and deletions\n// necessary to turn the first sequence into the second, and returns a\n// description of these changes.\n// \n// See Diff::LCS::DiffCallbacks for the default behaviour. An alternate\n// behaviour may be implemented with Diff::LCS::ContextDiffCallbacks.\n// If a Class argument is provided for +callbacks+, //diff will attempt\n// to initialise it. If the +callbacks+ object (possibly initialised)\n// responds to //finish, it will be called.\nDifference.LCS.diff = function(seq1, seq2, callbacks, block) {\n  callbacks = callbacks != null ? callbacks : Difference.LCS.DiffCallbacks;\n  \n  if(Object.prototype.toString.call(callbacks) == \"[object Function]\") {\n    callbacks = new callbacks();\n  }\n  \n  // Traverse the sequence\n  Difference.LCS.traverse_sequences(seq1, seq2, callbacks);  \n  if(callbacks.finish != null) callbacks.finish();\n  \n  if(block != null) {    \n    var res = callbacks.diffs.map(function(hunk) {\n      if(Array.isArray(hunk)) {\n        hunk = hunk.map(function(v) { return block(v); });\n      } else {\n        block(hunk);\n      }\n    });\n    \n    return res;\n  } else {    \n    return callbacks.diffs;\n  }\n}\n\n\n// Diff::LCS.traverse_sequences is the most general facility provided by this\n// module; +diff+ and +LCS+ are implemented as calls to it.\n//\n// The arguments to //traverse_sequences are the two sequences to\n// traverse, and a callback object, like this:\n//\n//   traverse_sequences(seq1, seq2, Diff::LCS::ContextDiffCallbacks.new)\n//\n// //diff is implemented with //traverse_sequences.\n//\n// == Callback Methods\n// Optional callback methods are <em>emphasized</em>.\n//\n// callbacks//match::               Called when +a+ and +b+ are pointing\n//                                 to common elements in +A+ and +B+.\n// callbacks//discard_a::           Called when +a+ is pointing to an\n//                                 element not in +B+.\n// callbacks//discard_b::           Called when +b+ is pointing to an\n//                                 element not in +A+.\n// <em>callbacks//finished_a</em>:: Called when +a+ has reached the end of\n//                                 sequence +A+.\n// <em>callbacks//finished_b</em>:: Called when +b+ has reached the end of\n//                                 sequence +B+.\n//\n// == Algorithm\n//       a---+\n//           v\n//       A = a b c e h j l m n p\n//       B = b c d e f j k l m r s t\n//           ^\n//       b---+\n//\n// If there are two arrows (+a+ and +b+) pointing to elements of\n// sequences +A+ and +B+, the arrows will initially point to the first\n// elements of their respective sequences. //traverse_sequences will\n// advance the arrows through the sequences one element at a time,\n// calling a method on the user-specified callback object before each\n// advance. It will advance the arrows in such a way that if there are\n// elements <tt>A[ii]</tt> and <tt>B[jj]</tt> which are both equal and\n// part of the longest common subsequence, there will be some moment\n// during the execution of //traverse_sequences when arrow +a+ is pointing\n// to <tt>A[ii]</tt> and arrow +b+ is pointing to <tt>B[jj]</tt>. When\n// this happens, //traverse_sequences will call <tt>callbacks//match</tt>\n// and then it will advance both arrows.\n//\n// Otherwise, one of the arrows is pointing to an element of its sequence\n// that is not part of the longest common subsequence.\n// //traverse_sequences will advance that arrow and will call\n// <tt>callbacks//discard_a</tt> or <tt>callbacks//discard_b</tt>, depending\n// on which arrow it advanced. If both arrows point to elements that are\n// not part of the longest common subsequence, then //traverse_sequences\n// will advance one of them and call the appropriate callback, but it is\n// not specified which it will call.\n//\n// The methods for <tt>callbacks//match</tt>, <tt>callbacks//discard_a</tt>,\n// and <tt>callbacks//discard_b</tt> are invoked with an event comprising\n// the action (\"=\", \"+\", or \"-\", respectively), the indicies +ii+ and\n// +jj+, and the elements <tt>A[ii]</tt> and <tt>B[jj]</tt>. Return\n// values are discarded by //traverse_sequences.\n//\n// === End of Sequences\n// If arrow +a+ reaches the end of its sequence before arrow +b+ does,\n// //traverse_sequence try to call <tt>callbacks//finished_a</tt> with the\n// last index and element of +A+ (<tt>A[-1]</tt>) and the current index\n// and element of +B+ (<tt>B[jj]</tt>). If <tt>callbacks//finished_a</tt>\n// does not exist, then <tt>callbacks//discard_b</tt> will be called on\n// each element of +B+ until the end of the sequence is reached (the call\n// will be done with <tt>A[-1]</tt> and <tt>B[jj]</tt> for each element).\n//\n// If +b+ reaches the end of +B+ before +a+ reaches the end of +A+,\n// <tt>callbacks//finished_b</tt> will be called with the current index\n// and element of +A+ (<tt>A[ii]</tt>) and the last index and element of\n// +B+ (<tt>A[-1]</tt>). Again, if <tt>callbacks//finished_b</tt> does not\n// exist on the callback object, then <tt>callbacks//discard_a</tt> will\n// be called on each element of +A+ until the end of the sequence is\n// reached (<tt>A[ii]</tt> and <tt>B[-1]</tt>).\n//\n// There is a chance that one additional <tt>callbacks//discard_a</tt> or\n// <tt>callbacks//discard_b</tt> will be called after the end of the\n// sequence is reached, if +a+ has not yet reached the end of +A+ or +b+\n// has not yet reached the end of +B+.\nDifference.LCS.traverse_sequences = function(seq1, seq2, callbacks, block) { // The block allows callbacks on change events\n  // Ensure that we have at least a default callback object\n  callbacks = callbacks != null ? callbacks : new Difference.LCS.SequenceCallbacks();\n  // Fetch the matches from the __lcs algorithm\n  var matches = Difference.LCS.__lcs(seq1, seq2);\n  \n  var run_finished_a = false, run_finished_b = false;\n  var string = seq1.constructor == String;\n  \n  var a_size = seq1.length, b_size = seq2.length;\n  var ai = 0, bj = 0;\n  var event = null;\n  \n  for(var ii = 0; ii <= matches.length; ii++) {\n    var b_line = matches[ii];\n    \n    var ax = string ? seq1.substr(ii, 1) : seq1[ii];\n    var bx = string ? seq2.substr(bj, bj + 1) : seq2[bj];\n\n    if(b_line == null) {\n      if(ax != null) {\n        event = new Difference.LCS.ContextChange('-', ii, ax, bj, bx);\n        if(block != null) event = block(event);\n        callbacks.discard_a(event);\n      }\n    } else {\n      while(bj < b_line) {\n        bx = string ? seq2.substr(bj, 1) : seq2[bj];\n        event = new Difference.LCS.ContextChange('+', ii, ax, bj, bx);\n        if(block != null) event = block(event);\n        callbacks.discard_b(event);\n        bj = bj + 1;\n      }\n      \n      bx = string ? seq2.substr(bj, 1) : seq2[bj];\n      event = new Difference.LCS.ContextChange('=', ii, ax, bj, bx);\n      if(block != null) event = block(event);\n      callbacks.match(event);\n      bj = bj + 1;\n    }\n    \n    // Update the ai with the current index point\n    ai = ii;    \n  }\n  \n  // Update pointer\n  ai = ai + 1;\n  \n  // The last entry (if any) processed was a match. +ai+ and +bj+ point\n  // just past the last matching lines in their sequences.\n  while(ai < a_size || bj < b_size) {\n    // last A\n    if(ai == a_size && bj < b_size) {\n      if(callbacks.finished_a != null && !run_finished_a) {\n        ax = string ? seq1.substr(seq1.length - 1, 1) : seq1[seq1.length - 1];\n        bx = string ? seq2.substr(bj, 1) : seq2[bj];\n        event = new Difference.LCS.ContextChange('>', (a_size - 1), ax, bj, bx);\n        if(block != null) event = block(event);\n        callbacks.finished_a(event);\n        run_finished_a = true;\n      } else {        \n        ax = string ? seq1.substr(ai, 1) : seq1[ai];\n        do {\n          bx = string ? seq2.substr(bj, 1) : seq2[bj];\n          event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n          if(block != null) event = block(event);\n          callbacks.discard_b(event);\n          bj = bj + 1;          \n        } while(bj < b_size)\n      }\n    }\n    \n    // last B?\n    if(bj == b_size && ai < a_size) {\n      if(callbacks.finished_b != null && !run_finished_b) {\n        ax = string ? seq1.substr(ai, 1) : seq1[ai];\n        bx = string ? seq2.substr(seq2.length - 1, 1) : seq2[seq2.length - 1];\n        event = new Difference.LCS.ContextChange('<', ai, ax, (b_size -1), bx);\n        if(block != null) event = block(event);\n        callbacks.finished_b(event);\n        run_finished_b = true;\n      } else {\n        bx = string ? seq2.substr(bj, 1) : seq2[bj];\n        do {\n          ax = string ? seq1.substr(ai, 1) : seq1[ai];\n          event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n          if(block != null) event = block(event);\n          callbacks.discard_a(event);\n          ai = ai + 1;        \n        } while(bj < b_size)\n      }\n    }    \n    \n    if(ai < a_size) {\n      ax = string ? seq1.substr(ai, 1) : seq1[ai];\n      bx = string ? seq2.substr(bj, 1) : seq2[bj];\n      event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n      if(block != null) event = block(event);\n      callbacks.discard_a(event);\n      ai = ai + 1;\n    }\n\n    if(bj < b_size) {\n      ax = string ? seq1.substr(ai, 1) : seq1[ai];\n      bx = string ? seq2.substr(bj, 1) : seq2[bj];\n      event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n      if(block != null) event = block(event);\n      callbacks.discard_b(event);\n      bj = bj + 1;\n    }      \n  }  \n}\n\n// //traverse_balanced is an alternative to //traverse_sequences. It\n// uses a different algorithm to iterate through the entries in the\n// computed longest common subsequence. Instead of viewing the changes as\n// insertions or deletions from one of the sequences, //traverse_balanced\n// will report <em>changes</em> between the sequences. To represent a\n//\n// The arguments to //traverse_balanced are the two sequences to traverse\n// and a callback object, like this:\n//\n//   traverse_balanced(seq1, seq2, Diff::LCS::ContextDiffCallbacks.new)\n//\n// //sdiff is implemented with //traverse_balanced.\n//\n// == Callback Methods\n// Optional callback methods are <em>emphasized</em>.\n//\n// callbacks//match::               Called when +a+ and +b+ are pointing\n//                                 to common elements in +A+ and +B+.\n// callbacks//discard_a::           Called when +a+ is pointing to an\n//                                 element not in +B+.\n// callbacks//discard_b::           Called when +b+ is pointing to an\n//                                 element not in +A+.\n// <em>callbacks//change</em>::     Called when +a+ and +b+ are pointing\n//                                 to the same relative position, but\n//                                 <tt>A[a]</tt> and <tt>B[b]</tt> are\n//                                 not the same; a <em>change</em> has\n//                                 occurred.\n//\n// //traverse_balanced might be a bit slower than //traverse_sequences,\n// noticable only while processing huge amounts of data.\n//\n// The +sdiff+ function of this module is implemented as call to\n// //traverse_balanced.\n//\n// == Algorithm\n//       a---+\n//           v\n//       A = a b c e h j l m n p\n//       B = b c d e f j k l m r s t\n//           ^\n//       b---+\n//\n// === Matches\n// If there are two arrows (+a+ and +b+) pointing to elements of\n// sequences +A+ and +B+, the arrows will initially point to the first\n// elements of their respective sequences. //traverse_sequences will\n// advance the arrows through the sequences one element at a time,\n// calling a method on the user-specified callback object before each\n// advance. It will advance the arrows in such a way that if there are\n// elements <tt>A[ii]</tt> and <tt>B[jj]</tt> which are both equal and\n// part of the longest common subsequence, there will be some moment\n// during the execution of //traverse_sequences when arrow +a+ is pointing\n// to <tt>A[ii]</tt> and arrow +b+ is pointing to <tt>B[jj]</tt>. When\n// this happens, //traverse_sequences will call <tt>callbacks//match</tt>\n// and then it will advance both arrows.\n//\n// === Discards\n// Otherwise, one of the arrows is pointing to an element of its sequence\n// that is not part of the longest common subsequence.\n// //traverse_sequences will advance that arrow and will call\n// <tt>callbacks//discard_a</tt> or <tt>callbacks//discard_b</tt>,\n// depending on which arrow it advanced.\n//\n// === Changes\n// If both +a+ and +b+ point to elements that are not part of the longest\n// common subsequence, then //traverse_sequences will try to call\n// <tt>callbacks//change</tt> and advance both arrows. If\n// <tt>callbacks//change</tt> is not implemented, then\n// <tt>callbacks//discard_a</tt> and <tt>callbacks//discard_b</tt> will be\n// called in turn.\n//\n// The methods for <tt>callbacks//match</tt>, <tt>callbacks//discard_a</tt>,\n// <tt>callbacks//discard_b</tt>, and <tt>callbacks//change</tt> are\n// invoked with an event comprising the action (\"=\", \"+\", \"-\", or \"!\",\n// respectively), the indicies +ii+ and +jj+, and the elements\n// <tt>A[ii]</tt> and <tt>B[jj]</tt>. Return values are discarded by\n// //traverse_balanced.\n//\n// === Context\n// Note that +ii+ and +jj+ may not be the same index position, even if\n// +a+ and +b+ are considered to be pointing to matching or changed\n// elements.\nDifference.LCS.traverse_balanced = function(seq1, seq2, callbacks, block) {\n  // Ensure that we have at least a default callback object\n  callbacks = callbacks != null ? callbacks : new Difference.LCS.BalancedCallbacks();\n  // Fetch the matches from the __lcs algorithm\n  var matches = Difference.LCS.__lcs(seq1, seq2);  \n  var a_size = seq1.length;\n  var b_size = seq2.length;\n  var ai = 0, bj = 0;\n  var mb = 0;\n  var ma = -1;\n  var string = seq1.constructor == String;\n  var ax = null, bx = null, event = null;\n  var execute = true;\n\n  // Process all the lines in the match vector.\n  while(true) {\n    // Find next match indices +ma+ and +mb+\n    while(execute) {\n      ma = ma + 1;\n      if(!(ma < matches.length && matches[ma] == null)) break;\n      // execute = !(ma < matches.length && matches[ma] == null);\n    }\n\n    if(ma >= matches.length) break; // end of matches\n    mb = matches[ma];\n\n    // Change seq2\n    while((ai < ma) || (bj < mb)) {\n      ax = string ? seq1.substr(ai, 1) : seq1[ai];\n      bx = string ? seq2.substr(bj, 1) : seq2[bj];\n      \n      // Calculate result\n      var result = [(ai < ma), (bj < mb)];\n      \n      if(result[0] && result[1]) {\n        if(callbacks.change != null) {\n          event = new Difference.LCS.ContextChange('!', ai, ax, bj, bx);\n          if(block != null) event = block(event);\n          callbacks.change(event);\n          ai = ai + 1;\n          bj = bj + 1;\n        } else {\n          event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n          if(block != null) event = block(event);\n          callbacks.discard_a(event);\n          ai = ai + 1;\n          ax = string ? seq1.substr(ai, 1) : seq1[ai];\n          event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n          if(block != null) event = block(event);\n          callbacks.discard_b(event);\n          bj = bj + 1\n        }\n      } else if(result[0] && !result[1]) {\n        event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n        if(block != null) event = block(event);\n        callbacks.discard_a(event);\n        ai = ai + 1;\n      } else if(!result[0] && result[1]) {\n        event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n        if(block != null) event = block(event);\n        callbacks.discard_b(event);\n        bj = bj + 1;\n      }      \n    }\n    \n    // Match\n    ax = string ? seq1.substr(ai, 1) : seq1[ai];\n    bx = string ? seq2.substr(bj, 1) : seq2[bj];\n    event = new Difference.LCS.ContextChange('=', ai, ax, bj, bx);\n    if(block != null) event = block(event);\n    callbacks.match(event);\n    ai = ai + 1;\n    bj = bj + 1;    \n  }\n  \n  while((ai < a_size) || (bj < b_size)) {\n    ax = string ? seq1.substr(ai, 1) : seq1[ai];\n    bx = string ? seq2.substr(bj, 1) : seq2[bj];\n    \n    var result = [(ai < a_size), (bj < b_size)];\n    if(result[0] && result[1]) {\n      if(callbacks.change != null) {\n        event = new Difference.LCS.ContextChange('!', ai, ax, bj, bx);\n        if(block != null) event = block(event);\n        callbacks.change(event);\n        ai = ai + 1;\n        bj = bj + 1;\n      } else {\n        event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n        if(block != null) event = block(event);\n        callbacks.discard_a(event);\n        ai = ai + 1;\n        ax = string ? seq1.substr(ai, 1) : seq1[ai];\n        event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n        if(block != null) event = block(event);\n        callbacks.discard_b(event);\n        bj = bj + 1;        \n      }\n    } else if(result[0] && !result[1]) {\n      event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n      if(block != null) event = block(event);\n      callbacks.discard_a(event);\n      ai = ai + 1;\n    } else if(!result[0] && result[1]) {\n      event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n      if(block != null) event = block(event);\n      callbacks.discard_b(event);\n      bj = bj + 1;\n    }\n  }\n}\n\n// Given two sequenced Enumerables, LCS returns an Array containing their\n// longest common subsequences.\n// \n//   lcs = Diff::LCS.LCS(seq1, seq2)\n// \n// This array whose contents is such that:\n// \n//   lcs.each_with_index do |ee, ii|\n//     assert(ee.nil? || (seq1[ii] == seq2[ee]))\n//   end\n// \n// If a block is provided, the matching subsequences will be yielded from\n// +seq1+ in turn and may be modified before they are placed into the\n// returned Array of subsequences.\nDifference.LCS.LCS = function(seq1, seq2, block) {\n  var matches = Difference.LCS.__lcs(seq1, seq2);\n  var ret = [];\n  \n  for(var ii = 0; ii < matches.length; ii++) {\n    if(matches[ii] != null) {\n      if(block != null) {\n        ret.push(block(seq1[ii]));\n      } else {\n        ret.push(seq1[ii]);\n      }\n    }\n  }\n  // Return the result\n  return ret;\n}\n\nvar PATCH_MAP = {\n  patch:{ '+':'+', '-':'-', '!':'!', '=':'=' },\n  unpatch:{ '+':'-', '-':'+', '!':'!', '=':'=' }\n}\n\n// Given a patchset, convert the current version to the new\n// version. If +direction+ is not specified (must be\n// <tt>:patch</tt> or <tt>:unpatch</tt>), then discovery of the\n// direction of the patch will be attempted.\nDifference.LCS.patch = function(src, patchset, direction) {\n  var string = src.constructor == String;\n  // Start with an empty type of the source's class\n  var res = string ? '' : [];\n  \n  // Normalize the patchset\n  var patchset = this.__normalize_patchset(patchset);\n  var direction = direction || Difference.LCS.__diff_direction(src, patchset);\n  direction = direction || \"patch\";\n  \n  var ai = 0, bj = 0;\n  var el = null, op = null, np = null;\n  \n  for(var i = 0; i < patchset.length; i++) {\n    var change = patchset[i];\n    // Both Change and ContextChange has the action\n    var action = PATCH_MAP[direction][change.action];\n    \n    if(change instanceof ContextChange) {\n      if(direction == 'patch') {\n        el = change.new_element;\n        op = change.old_position;\n        np = change.new_position;\n      } else if(direction == 'unpatch') {\n        el = change.old_element;\n        op = change.new_position;\n        np = change.old_position;\n      }\n      \n      if(action == '-') { //Remove details from the old string\n        while(ai < op) {\n          string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n          ai = ai + 1;\n          bj = bj + 1;\n        }        \n        ai = ai + 1;\n      } else if(action == '+') {\n        while(bj < np) {\n          string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n          ai = ai + 1;\n          bj = bj + 1;\n        }\n        string ? res = res + el : res.push(el);\n        bj = bj + 1;\n      } else if(action == '=') {\n        // This only appears in sdiff output with the SDiff callback.\n        // Therefore, we only need to worry about dealing with a single\n        // element.\n        string ? res = res + el : res.push(el);\n        ai = ai + 1;\n        bj = bj + 1;\n      } else if(action == '!') {\n        while(ai < op) {\n          string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n          ai = ai + 1;\n          bj = bj + 1;\n        }\n        bj = bj + 1;\n        ai = ai + 1;\n        string ? res = res + el : res.push(el);\n      }\n    } else if(change instanceof Change) {\n      if(action == '-') {\n        while(ai < change.position) {\n          string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n          ai = ai + 1;\n          bj = bj + 1;\n        }\n        ai = ai + 1;\n      } else if(action = '+') {\n        while(bj < change.position) {\n          string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n          ai = ai + 1;\n          bj = bj + 1;\n        }\n        bj = bj + 1;\n        string ? res = res + change.element : res.push(change.element);\n      }\n    }    \n  }  \n  \n  while(ai < src.length) {\n    string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n    ai = ai + 1;\n    bj = bj + 1;\n  }\n  \n  return res;  \n}\n\n// Examine the patchset and the source to see in which direction the\n// patch should be applied.\n//\n// WARNING: By default, this examines the whole patch, so this could take\n// some time. This also works better with Diff::LCS::ContextChange or\n// Diff::LCS::Change as its source, as an array will cause the creation\n// of one of the above.\nDifference.LCS.__diff_direction = function(src, patchset, limit) {\n  var count = 0, left = 0, left_miss = 0, right = 0, right_miss = 0, element = null;\n  var string = src.constructor == String;\n\n  // Process all changes in the patchset\n  for(var i = 0; i < patchset.length; i++) {\n    var change = patchset[i];\n    count = count + 1;\n    \n    if(change instanceof Change) {\n      // With a simplistic change, we can't tell the difference between\n      // the left and right on '!' actions, so we ignore those. On '='\n      // actions, if there's a miss, we miss both left and right.\n      element = string ? src.substr(change.position, 1) : src[change.position];\n      \n      if(change.action == '-') {\n        element == change.element ? left = left + 1 : left_miss = left_miss + 1;\n      } else if(change.action == '+') {\n        element == change.element ? right = right + 1 : right_miss = right_miss + 1;\n      } else if(change.action == '=') {\n        if(element != change.element) {\n          left_miss = left_miss + 1;\n          right_miss = right_miss + 1;\n        }\n      }      \n    } else if(change instanceof ContextChange) {\n      if(change.action == '-') {\n        element = string ? src.substr(change.old_position, 1) : src[change.old_position];\n        element == change.old_element ? left = left + 1 : left_miss = left_miss + 1;        \n      } else if(change.action == '+') {\n        element = string ? src.substr(change.new_position, 1) : src[change.new_position];\n        element == change.new_element ? right = right + 1 : right_miss = right_miss + 1;\n      } else if(change.action == '=') {\n        var le = string ? src.substr(change.old_position, 1) : src[change.old_position];\n        var re = string ? src.substr(change.new_position, 1) : src[change.new_position];\n        \n        if(le != change.old_element) left_miss = left_miss + 1;\n        if(re != change.new_element) right_miss = right_miss + 1;\n      } else if(change.action == '!') {\n        element = string ? src.substr(change.old_position, 1) : src[change.old_position];\n        if(element == change.old_element) {\n          left = left + 1;\n        } else {\n          left_miss = left_miss + 1;\n          right_miss = right_miss + 1;\n        }\n      }\n    }\n    \n    if(limit != null && count > limit) break;\n  };\n  \n  var no_left = (left == 0) && (left_miss >= 0);\n  var no_right = (right == 0) && (right_miss >= 0);\n  \n  var result = [no_left, no_right];\n  if(!no_left && no_right) {\n    return \"patch\";\n  } else if(no_left && !no_right) {\n    return \"unpatch\";\n  } else {\n    throw \"The provided patchset does not appear to apply to the provided value as either source or destination value.\"\n  }\n}\n\n// Normalize the patchset. A patchset is always a sequence of changes, but\n// how those changes are represented may vary, depending on how they were\n// generated. In all cases we support, we also support the array\n// representation of the changes. The formats are:\n//\n//   [ // patchset <- Diff::LCS.diff(a, b)\n//     [ // one or more hunks\n//       Diff::LCS::Change // one or more changes\n//     ] ]\n//\n//   [ // patchset, equivalent to the above\n//     [ // one or more hunks\n//       [ action, line, value ] // one or more changes\n//     ] ]\n//\n//   [ // patchset <- Diff::LCS.diff(a, b, Diff::LCS::ContextDiffCallbacks)\n//     //       OR <- Diff::LCS.sdiff(a, b, Diff::LCS::ContextDiffCallbacks)\n//     [ // one or more hunks\n//       Diff::LCS::ContextChange // one or more changes\n//     ] ]\n//\n//   [ // patchset, equivalent to the above\n//     [ // one or more hunks\n//       [ action, [ old line, old value ], [ new line, new value ] ]\n//         // one or more changes\n//     ] ]\n//\n//   [ // patchset <- Diff::LCS.sdiff(a, b)\n//     //       OR <- Diff::LCS.diff(a, b, Diff::LCS::SDiffCallbacks)\n//     Diff::LCS::ContextChange // one or more changes\n//   ]\n//\n//   [ // patchset, equivalent to the above\n//     [ action, [ old line, old value ], [ new line, new value ] ]\n//       // one or more changes\n//   ]\n//\n// The result of this will be either of the following.\n//\n//   [ // patchset\n//     Diff::LCS::ContextChange // one or more changes\n//   ]\n//\n//   [ // patchset\n//     Diff::LCS::Change // one or more changes\n//   ]\n//\n// If either of the above is provided, it will be returned as such.\n//\nDifference.LCS.__normalize_patchset = function(patchset) {\n  return flatten(patchset.map(function(hunk) {\n    if(hunk instanceof ContextChange || hunk instanceof Change) {\n      return hunk;\n    } else if(Array.isArray(hunk)) {\n      if(!Array.isArray(hunk[0]) && Array.isArray(hunk[1]) && Array.isArray(hunk[2])) {\n        return ContextChange.from_a(hunk);\n      } else {\n        return hunk.map(function(change) {\n          if(change instanceof ContextChange || change instanceof Change) {\n            return change;\n          } else if(Array.isArray(change)) {\n            // change[1] will ONLY be an array in a ContextChange#to_a call.\n            // In Change#to_a, it represents the line (singular).\n            if(Array.isArray(change[1])) {\n              return ContextChange.from_a(change);\n            } else {\n              return Change.from_a(change);\n            }\n          }\n        });\n      }      \n    } else {\n      throw \"Cannot normalize the hunk: \" + util.inspect(hunk);\n    }    \n  }));\n}\n\n// Gotten from\nvar flatten = function(array) {\n  return array.reduce(function(a,b) {  \n    return a.concat(b);  \n  }, []);\n}\n\n// Compute the longest common subsequence between the arrays a and b the result\n// being an array whose content is such that they \n// count = 0\n// result.forEach(function(e) {\n//  if(e) a[count] == b[e];\n//  count++; \n// })\nDifference.LCS.__lcs = function(a, b) {\n  var a_start = 0;\n  var b_start = 0;\n  var a_finish = a.length - 1;\n  var b_finish = b.length - 1;\n  var vector = [];\n    \n  // Remove common elements at the beginning\n  while((a_start <= a_finish) && (b_start <= b_finish) && (a[a_start] == b[b_start])) {\n    vector[a_start] = b_start;\n    a_start = a_start + 1;\n    b_start = b_start + 1;\n  }\n  \n  // Remove common elements at the end\n  while((a_start <= a_finish) && (b_start <= b_finish) && (a[a_finish] == b[b_finish])) {\n    vector[a_finish] = b_finish;\n    a_finish = a_finish - 1;\n    b_finish = b_finish - 1;\n  }\n  \n  // Now compute the equivalent classes of positions of elements\n  var b_matches = Difference.LCS.__position_hash(b, b_start, b_finish);\n  \n  // Define treshold and links\n  var thresh = [];\n  var links = [];\n  \n  for(var ii = a_start; ii <= a_finish; ii++) {\n    var ai = Array.isArray(a) ? a[ii] : a.charAt(ii);\n    var bm = b_matches[ai];\n    bm = bm ? bm : [];\n    var kk = null;\n    \n    bm.reverse().forEach(function(jj) {\n      if(kk != null && (thresh[kk] > jj) && (thresh[kk - 1] < jj)) {\n        thresh[kk] = jj;\n      } else {\n        kk = Difference.LCS.__replace_next_larger(thresh, jj, kk);\n      }\n      // Add link\n      if(kk != null) links[kk] = [(kk > 0) ? links[kk - 1] : null, ii, jj];\n    });\n  }\n    \n  // Build the vector\n  if(thresh.length > 0) {\n    var link = links[thresh.length - 1];\n    \n    while(link != null) {\n      vector[link[1]] = link[2];\n      link = link[0];\n    }\n  }\n  \n  // Return the vector of the longest commong subsequence\n  return vector;\n}\n\n// Find the place at which +value+ would normally be inserted into the\n// Enumerable. If that place is already occupied by +value+, do nothing\n// and return +nil+. If the place does not exist (i.e., it is off the end\n// of the Enumerable), add it to the end. Otherwise, replace the element\n// at that point with +value+. It is assumed that the Enumerable's values\n// are numeric.\n//\n// This operation preserves the sort order.\nDifference.LCS.__replace_next_larger = function(enumerable, value, last_index) {\n  // Is it off the end\n  if(enumerable.length == 0 || (value > enumerable[enumerable.length - 1])) {\n    enumerable.push(value);\n    return enumerable.length - 1;\n  }\n  \n  // Binary search for the insertion point\n  var last_index = last_index || enumerable.length;\n  var first_index = 0;\n  \n  while(first_index <= last_index) {\n    var ii = (first_index + last_index) >> 1;\n    var found = enumerable[ii];\n    \n    if(value == found) {\n      return null;\n    } else if(value > found) {\n      first_index = ii + 1;\n    } else {\n      last_index = ii - 1;\n    }\n  }\n  \n  // The insertion point is in first_index; overwrite the next larger\n  // value.\n  enumerable[first_index] = value;\n  return first_index;\n}\n\nDifference.LCS.__position_hash = function(enumerable, interval_start, interval_end) {\n  interval_start = interval_start ? interval_start : 0;\n  interval_end = interval_end ? interval_end : -1;\n  \n  var hash = {}\n  for(var i = interval_start; i <= interval_end; i++) {\n    var kk = Array.isArray(enumerable) ? enumerable[i] : enumerable.charAt(i);\n    hash[kk] = Array.isArray(hash[kk]) ? hash[kk] : [];\n    hash[kk].push(i);\n  }\n  return hash;\n}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/diff/callbacks.js":"var ContextChange = require('./change').ContextChange,\n  Change = require('./change').Change;\n\n// This callback object implements the default set of callback events, which\n// only returns the event itself. Note that //finished_a and //finished_b are\n// not implemented -- I haven't yet figured out where they would be useful.\n//\n// Note that this is intended to be called as is, e.g.,\nDefaultCallbacks = exports.DefaultCallbacks = function() {  \n}\n\n// Called when two items match.\nDefaultCallbacks.prototype.match = function(event) {\n  return event;\n}\n\n// Called when the old value is discarded in favour of the new value.\nDefaultCallbacks.prototype.discard_a = function(event) {\n  return event;\n}\n\n// Called when the new value is discarded in favour of the old value.\nDefaultCallbacks.prototype.discard_b = function(event) {\n  return event;\n}\n\n// Called when both the old and new values have changed.\nDefaultCallbacks.prototype.change = function(event) {\n  return event;\n}\n\n// An alias for DefaultCallbacks that is used in Diff::LCS#traverse_sequences.\nSequenceCallbacks = exports.SequenceCallbacks = DefaultCallbacks;\n// An alias for DefaultCallbacks that is used in Diff::LCS#traverse_balanced.\nBalancedCallbacks = exports.BalancedCallbacks = DefaultCallbacks;\n\n// This will produce a compound array of simple diff change objects. Each\n// element in the //diffs array is a +hunk+ or +hunk+ array, where each\n// element in each +hunk+ array is a single Change object representing the\n// addition or removal of a single element from one of the two tested\n// sequences. The +hunk+ provides the full context for the changes.\n//\n//     diffs = Diff::LCS.diff(seq1, seq2)\n//       // This example shows a simplified array format.\n//       // [ [ [ '-',  0, 'a' ] ],   // 1\n//       //   [ [ '+',  2, 'd' ] ],   // 2\n//       //   [ [ '-',  4, 'h' ],     // 3\n//       //     [ '+',  4, 'f' ] ],\n//       //   [ [ '+',  6, 'k' ] ],   // 4\n//       //   [ [ '-',  8, 'n' ],     // 5\n//       //     [ '-',  9, 'p' ],\n//       //     [ '+',  9, 'r' ],\n//       //     [ '+', 10, 's' ],\n//       //     [ '+', 11, 't' ] ] ]\n//\n// There are five hunks here. The first hunk says that the +a+ at position 0\n// of the first sequence should be deleted (<tt>'-'</tt>). The second hunk\n// says that the +d+ at position 2 of the second sequence should be inserted\n// (<tt>'+'</tt>). The third hunk says that the +h+ at position 4 of the\n// first sequence should be removed and replaced with the +f+ from position 4\n// of the second sequence. The other two hunks are described similarly.\n//\n// === Use\n// This callback object must be initialised and is used by the Diff::LCS//diff\n// method.\n//\n//     cbo = Diff::LCS::DiffCallbacks.new\n//     Diff::LCS.LCS(seq1, seq2, cbo)\n//     cbo.finish\n//\n// Note that the call to //finish is absolutely necessary, or the last set of\n// changes will not be visible. Alternatively, can be used as:\n//\n//     cbo = Diff::LCS::DiffCallbacks.new { |tcbo| Diff::LCS.LCS(seq1, seq2, tcbo) }\n//\n// The necessary //finish call will be made.\n//\n// === Simplified Array Format\n// The simplified array format used in the example above can be obtained\n// with:\n//\n//     require 'pp'\n//     pp diffs.map { |e| e.map { |f| f.to_a } }\nDiffCallbacks = exports.DiffCallbacks = function(block) {\n  this.hunk = [];\n  this.diffs = [];\n  \n  if(block != null)  {\n    block(this);\n    this.finish();\n  }\n}\n\n// Finalizes the diff process. If an unprocessed hunk still exists, then it\n// is appended to the diff list.\nDiffCallbacks.prototype.finish = function() {\n  add_nonempty_hunk(this);\n}\n\nDiffCallbacks.prototype.match = function(event) {\n  add_nonempty_hunk(this);\n}\n\nDiffCallbacks.prototype.discard_a = function(event) {\n  this.hunk.push(new Change('-', event.old_position, event.old_element));\n}\n\nDiffCallbacks.prototype.discard_b = function(event) {\n  this.hunk.push(new Change('+', event.new_position, event.new_element));\n}\n\nvar add_nonempty_hunk = function(diff_callback) {\n  if(diff_callback.hunk.length > 0) diff_callback.diffs.push(diff_callback.hunk);\n  diff_callback.hunk = [];\n}\n\n// This will produce a simple array of diff change objects. Each element in\n// the //diffs array is a single ContextChange. In the set of //diffs provided\n// by SDiffCallbacks, both old and new objects will be presented for both\n// changed <strong>and unchanged</strong> objects. +nil+ will be substituted\n// for a discarded object.\n//\n// The diffset produced by this callback, when provided to Diff::LCS//sdiff,\n// will compute and display the necessary components to show two sequences\n// and their minimized differences side by side, just like the Unix utility\n// +sdiff+.\n// \n//     same             same\n//     before     |     after\n//     old        <     -\n//     -          >     new\n//\n//     seq1 = %w(a b c e h j l m n p)\n//     seq2 = %w(b c d e f j k l m r s t)\n//\n//     diffs = Diff::LCS.sdiff(seq1, seq2)\n//       // This example shows a simplified array format.\n//       // [ [ \"-\", [  0, \"a\"], [  0, nil ] ],\n//       //   [ \"=\", [  1, \"b\"], [  0, \"b\" ] ],\n//       //   [ \"=\", [  2, \"c\"], [  1, \"c\" ] ],\n//       //   [ \"+\", [  3, nil], [  2, \"d\" ] ],\n//       //   [ \"=\", [  3, \"e\"], [  3, \"e\" ] ],\n//       //   [ \"!\", [  4, \"h\"], [  4, \"f\" ] ],\n//       //   [ \"=\", [  5, \"j\"], [  5, \"j\" ] ],\n//       //   [ \"+\", [  6, nil], [  6, \"k\" ] ],\n//       //   [ \"=\", [  6, \"l\"], [  7, \"l\" ] ],\n//       //   [ \"=\", [  7, \"m\"], [  8, \"m\" ] ],\n//       //   [ \"!\", [  8, \"n\"], [  9, \"r\" ] ],\n//       //   [ \"!\", [  9, \"p\"], [ 10, \"s\" ] ],\n//       //   [ \"+\", [ 10, nil], [ 11, \"t\" ] ] ]\n//\n// The result of this operation is similar to that of\n// Diff::LCS::ContextDiffCallbacks. They may be compared as:\n//\n//     s = Diff::LCS.sdiff(seq1, seq2).reject { |e| e.action == \"=\" }\n//     c = Diff::LCS.sdiff(seq1, seq2, Diff::LCS::ContextDiffCallbacks).flatten\n//\n//     s == c // -> true\n//\n// === Use\n// This callback object must be initialised and is used by the Diff::LCS//sdiff\n// method.\n//\n//     cbo = Diff::LCS::SDiffCallbacks.new\n//     Diff::LCS.LCS(seq1, seq2, cbo)\n//\n// As with the other initialisable callback objects, Diff::LCS::SDiffCallbacks\n// can be initialised with a block. As there is no \"fininishing\" to be done,\n// this has no effect on the state of the object.\n//\n//     cbo = Diff::LCS::SDiffCallbacks.new { |tcbo| Diff::LCS.LCS(seq1, seq2, tcbo) }\n//\n// === Simplified Array Format\n// The simplified array format used in the example above can be obtained\n// with:\n//\n//     require 'pp'\n//     pp diffs.map { |e| e.to_a }\nSDiffCallbacks = exports.SDiffCallbacks = function(block) {\n  this.diffs = [];\n  \n  if(block != null)  {\n    block(this);\n    this.finish();\n  }\n}\n\nSDiffCallbacks.prototype.match = function(event) {\n  this.diffs.push(ContextChange.simplify(event));\n}\n\nSDiffCallbacks.prototype.discard_a = function(event) {\n  this.diffs.push(ContextChange.simplify(event));\n}\n\nSDiffCallbacks.prototype.discard_b = function(event) {\n  this.diffs.push(ContextChange.simplify(event));\n}\n\nSDiffCallbacks.prototype.change = function(event) {\n  this.diffs.push(ContextChange.simplify(event));\n}\n\n// This will produce a compound array of contextual diff change objects. Each\n// element in the //diffs array is a \"hunk\" array, where each element in each\n// \"hunk\" array is a single change. Each change is a Diff::LCS::ContextChange\n// that contains both the old index and new index values for the change. The\n// \"hunk\" provides the full context for the changes. Both old and new objects\n// will be presented for changed objects. +nil+ will be substituted for a\n// discarded object.\n//\n//     seq1 = %w(a b c e h j l m n p)\n//     seq2 = %w(b c d e f j k l m r s t)\n//\n//     diffs = Diff::LCS.diff(seq1, seq2, Diff::LCS::ContextDiffCallbacks)\n//       // This example shows a simplified array format.\n//       // [ [ [ '-', [  0, 'a' ], [  0, nil ] ] ],   // 1\n//       //   [ [ '+', [  3, nil ], [  2, 'd' ] ] ],   // 2\n//       //   [ [ '-', [  4, 'h' ], [  4, nil ] ],     // 3\n//       //     [ '+', [  5, nil ], [  4, 'f' ] ] ],\n//       //   [ [ '+', [  6, nil ], [  6, 'k' ] ] ],   // 4\n//       //   [ [ '-', [  8, 'n' ], [  9, nil ] ],     // 5\n//       //     [ '+', [  9, nil ], [  9, 'r' ] ],\n//       //     [ '-', [  9, 'p' ], [ 10, nil ] ],\n//       //     [ '+', [ 10, nil ], [ 10, 's' ] ],\n//       //     [ '+', [ 10, nil ], [ 11, 't' ] ] ] ]\n//\n// The five hunks shown are comprised of individual changes; if there is a\n// related set of changes, they are still shown individually.\n//\n// This callback can also be used with Diff::LCS//sdiff, which will produce\n// results like:\n//\n//     diffs = Diff::LCS.sdiff(seq1, seq2, Diff::LCS::ContextCallbacks)\n//       // This example shows a simplified array format.\n//       // [ [ [ \"-\", [  0, \"a\" ], [  0, nil ] ] ],  // 1\n//       //   [ [ \"+\", [  3, nil ], [  2, \"d\" ] ] ],  // 2\n//       //   [ [ \"!\", [  4, \"h\" ], [  4, \"f\" ] ] ],  // 3\n//       //   [ [ \"+\", [  6, nil ], [  6, \"k\" ] ] ],  // 4\n//       //   [ [ \"!\", [  8, \"n\" ], [  9, \"r\" ] ],    // 5\n//       //     [ \"!\", [  9, \"p\" ], [ 10, \"s\" ] ],\n//       //     [ \"+\", [ 10, nil ], [ 11, \"t\" ] ] ] ]\n//\n// The five hunks are still present, but are significantly shorter in total\n// presentation, because changed items are shown as changes (\"!\") instead of\n// potentially \"mismatched\" pairs of additions and deletions.\n//\n// The result of this operation is similar to that of\n// Diff::LCS::SDiffCallbacks. They may be compared as:\n//\n//     s = Diff::LCS.sdiff(seq1, seq2).reject { |e| e.action == \"=\" }\n//     c = Diff::LCS.sdiff(seq1, seq2, Diff::LCS::ContextDiffCallbacks).flatten\n//\n//     s == c // -> true\n//\n// === Use\n// This callback object must be initialised and can be used by the\n// Diff::LCS//diff or Diff::LCS//sdiff methods.\n//\n//     cbo = Diff::LCS::ContextDiffCallbacks.new\n//     Diff::LCS.LCS(seq1, seq2, cbo)\n//     cbo.finish\n//\n// Note that the call to //finish is absolutely necessary, or the last set of\n// changes will not be visible. Alternatively, can be used as:\n//\n//     cbo = Diff::LCS::ContextDiffCallbacks.new { |tcbo| Diff::LCS.LCS(seq1, seq2, tcbo) }\n//\n// The necessary //finish call will be made.\n//\n// === Simplified Array Format\n// The simplified array format used in the example above can be obtained\n// with:\n//\n//     require 'pp'\n//     pp diffs.map { |e| e.map { |f| f.to_a } }\nContextDiffCallbacks = exports.ContextDiffCallbacks = function(block) {\n  this.hunk = [];\n  this.diffs = [];\n  \n  if(block != null)  {\n    block(this);\n    this.finish();\n  }\n}\n\nContextDiffCallbacks.prototype.finish = function() {\n  add_nonempty_hunk(this);\n}\n\nContextDiffCallbacks.prototype.discard_a = function(event) {\n  this.hunk.push(ContextChange.simplify(event));\n}\n\nContextDiffCallbacks.prototype.discard_b = function(event) {\n  this.hunk.push(ContextChange.simplify(event));\n}\n\nContextDiffCallbacks.prototype.match = function(event) {\n  this.hunk.push(ContextChange.simplify(event));\n}\n\n\n\n\n\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/diff/change.js":"// Represents a simplistic (non-contextual) change. Represents the removal or\n// addition of an element from either the old or the new sequenced enumerable.\nvar Change = exports.Change = function(action, position, element) {\n  this.action = action;\n  this.position = position;\n  this.element = element;  \n}\n\nChange.from_a = function(arr) {\n  return new Change(arr[0], arr[1], arr[2]);\n}\n\nChange.prototype.to_a = function() {\n  return [this.action, this.position, this.element];\n}\n\nChange.prototype.is_deleting = function() {\n  return this.action == '-';\n}\n\nChange.prototype.is_adding = function() {\n  return this.action == '+';\n}\n\nChange.prototype.is_unchanged = function() {\n  return this.action == '=';\n}\n\nChange.prototype.is_changed = function() {\n  return this.changed == '!';\n}\n\nChange.prototype.is_finished_a = function() {\n  return this.changed == '>';\n}\n\nChange.prototype.is_finished_b = function() {\n  return this.changed == '<';\n}\n\nvar ContextChange = exports.ContextChange = function(action, old_position, old_element, new_position, new_element) {\n  this.action = action;\n  this.old_position = old_position;\n  this.old_element = old_element;\n  this.new_position = new_position;\n  this.new_element = new_element;\n}\n\n// Creates a ContextChange from an array produced by ContextChange#to_a.\nContextChange.from_a = function(arr) {\n  if(arr.length == 5) {\n    return new ContextChange(arr[0], arr[1], arr[2], arr[3], arr[4]);\n  } else {\n    return new ContextChange(arr[0], arr[1][0], arr[1][1], arr[2][0], arr[2][1]);\n  }\n}\n\n// Simplifies a context change for use in some diff callbacks. '<' actions\n// are converted to '-' and '>' actions are converted to '+'. \nContextChange.simplify = function(event) {\n  var ea = event.to_a();\n  \n  if(ea[0] == '-') {\n    ea[2][1] = null;\n  } else if(ea[0] == '<') {\n    ea[0] = '-';\n    ea[2][1] = null;\n  } else if(ea[0] == '+') {\n    ea[1][1] = null;\n  } else if(ea[0] == '>') {\n    ea[0] = '+';\n    ea[1][1] = null;\n  }\n  \n  // Return a Context Change object\n  return ContextChange.from_a(ea);\n}\n\nContextChange.prototype.to_a = function() {\n  return [this.action, [this.old_position, this.old_element], [this.new_position, this.new_element]];\n}\n\nContextChange.prototype.is_deleting = function() {\n  return this.action == '-';\n}\n\nContextChange.prototype.is_adding = function() {\n  return this.action == '+';\n}\n\nContextChange.prototype.is_unchanged = function() {\n  return this.action == '=';\n}\n\nContextChange.prototype.is_changed = function() {\n  return this.changed == '!';\n}\n\nContextChange.prototype.is_finished_a = function() {\n  return this.changed == '>';\n}\n\nContextChange.prototype.is_finished_b = function() {\n  return this.changed == '<';\n}\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/diff/hunk.js":"var Block = require('./block').Block;\n\n// A Hunk is a group of Blocks which overlap because of the context\n// surrounding each block. (So if we're not using context, every hunk will\n// contain one block.) Used in the diff program (bin/diff).\nvar Hunk = exports.Hunk = function(data_old, data_new, piece, context, file_length_difference) {  \n  // Internal variables\n  var _flag_context = null;\n  var self = this;\n  \n  // At first, a hunk will have just one Block in it\n  this.blocks = [new Block(piece)];\n  this.data_old = data_old;\n  this.data_new = data_new;\n  \n  var before = file_length_difference, after = file_length_difference;\n  after = after + this.blocks[0].diff_size;\n  this.file_length_difference = after; // The caller must get this manually\n  // Other parameters\n  var a1 = null, a2 = null;\n  var b1 = null, b2 = null;\n  \n  // Save the start & end of each array. If the array doesn't exist\n  // (e.g., we're only adding items in this block), then figure out the\n  // line number based on the line number of the other file and the\n  // current difference in file lengths.\n  if(this.blocks[0].remove.length > 0) {\n    a1 = this.blocks[0].remove[0].position;\n    a2 = this.blocks[0].remove[this.blocks[0].remove.length - 1].position;\n  }\n  \n  if(this.blocks[0].insert.length > 0) {\n    b1 = this.blocks[0].insert[0].position;\n    b2 = this.blocks[0].insert[this.blocks[0].insert.length - 1].position;\n  }\n    \n  this.start_old = a1 || (b1 - before);\n  this.start_new = b1 || (a1 + before);\n  this.end_old = a2 || (b2 - after);\n  this.end_new = b2 || (a2 + after);    \n  \n  // Change the \"start\" and \"end\" fields to note that context should be added\n  // to this hunk\n  Object.defineProperty(this, \"flag_context\", { get: function() { return _flag_context; }, set: function(context) { \n      if(context == null || context == 0) return null;\n      \n      var add_start = (context > self.start_old) ? self.start_old : context;\n      var add_end = null;\n      \n      self.start_old = self.start_old - add_start;\n      self.start_new = self.start_new - add_start;\n      \n      if((self.end_old + context) > self.data_old.length) {\n        add_end = self.data_old.length - self.end_old;\n      } else {\n        add_end = context;\n      }\n      \n      self.end_old = self.end_old + add_end;\n      self.end_new = self.end_new + add_end;\n      _flag_context = context;\n    }, enumerable: true});   \n    \n  // Set the flag_context\n  this.flag_context = context;     \n}\n\nHunk.prototype.unshift = function(hunk) {\n  this.start_old = hunk.start_old;\n  this.start_new = hunk.start_new;\n  this.blocks = hunk.blocks.concat(this.blocks);\n}\n\n// Is there an overlap between hunk arg0 and old hunk arg1? Note: if end\n// of old hunk is one less than beginning of second, they overlap\nHunk.prototype.overlaps = function(hunk) {\n  if(hunk == null) return null;\n  \n  var a = (this.start_old - hunk.end_old) <= 1;\n  var b = (this.start_new - hunk.end_new) <= 1;\n  return (a || b);\n}\n\nHunk.prototype.diff = function(format) {\n  if(format == \"old\") {\n    return old_diff(this);    \n  } else if(format == 'unified') {\n    return unified_diff(this);\n  } else if(format == 'context') {\n    return context_diff(this);\n  } else if(format == 'ed') {\n    return this;\n  } else if(format == 'reverse_ed' || format == 'ed_finish') {\n    return ed_diff(this, format);\n  } else {\n    throw \"unknown diff format \" + format;\n  }\n}\n\nHunk.prototype.each_old = function(block) {\n  var entries = this.data_old.slice(this.start_old, this.end_old);\n  entries.forEach(function(e) {\n    block(e);\n  });\n}\n\n// Note that an old diff can't have any context. Therefore, we know that\n// there's only one block in the hunk.\nvar old_diff = function(hunk) {\n  if(hunk.blocks.length > 1) sys.puts(\"expecting only one block in an old diff hunk!\");\n  // Set up operation actions\n  var opt_act = {'+':'a', '-':'d', '!':'c'};\n  var block = hunk.blocks[0];\n  \n  // Calculate item number range. Old diff range is just like a context\n  // diff range, except the ranges are on one line with the action between\n  // them.\n  var s = \"\" + context_rang(\"old\") + opt_act[block.op] + context_rang(\"new\") + \"\\n\";\n  // If removing anything, just print out all the remove lines in the hunk\n  // which is just all the remove lines in the block.\n  if(block.remove.length > 0) {\n    hunk.data_old.slice(hunk.start_old, hunk.end_old).forEach(function(e) {\n      s = s + \"< \" + e + \"\\n\";\n    });    \n  }\n  \n  if(block.insert.length > 0) {\n    hunk.data_new.slice(hunk.start_new, hunk.end_new).forEach(function(e) {\n      s = s + \"> \" + e + \"\\n;\"\n    });\n  }\n  // Return the diff string\n  return s;\n}\n\nvar unified_diff = function(hunk) {\n  // Calculate item number range.\n  var s = \"@@ -\" + unified_range(hunk, 'old') + \" +\" + unified_range(hunk, 'new') + \" @@\\n\";\n\n  // Outlist starts containing the hunk of the old file. Removing an item\n  // just means putting a '-' in front of it. Inserting an item requires\n  // getting it from the new file and splicing it in. We splice in\n  // +num_added+ items. Remove blocks use +num_added+ because splicing\n  // changed the length of outlist.\n  //\n  // We remove +num_removed+ items. Insert blocks use +num_removed+\n  // because their item numbers -- corresponding to positions in the NEW\n  // file -- don't take removed items into account.\n  var lo = hunk.start_old;\n  var hi = hunk.end_old;\n  var num_added = 0;\n  var num_removed = 0;\n  \n  // Create list of stripped entries\n  var outlist = hunk.data_old.slice(lo, hi + 1).map(function(e) { return e.replace(/^/g, ' '); });\n  // Process all the blocks\n  hunk.blocks.forEach(function(block) {\n    block.remove.forEach(function(item) {\n      var op = item.action.toString();  // -\n      var offset = item.position - lo + num_added;\n      outlist[offset] = outlist[offset].replace(/^ /g, op.toString());\n      num_removed = num_removed + 1;\n    })\n    \n    block.insert.forEach(function(item) {\n      var op = item.action.toString(); // +\n      var offset = item.position - hunk.start_new + num_removed;\n      outlist.splice(offset, 0, (\"\" + op + hunk.data_new[item.position]));\n      num_added = num_added + 1;\n    });\n  });\n  \n  // Return the list\n  return s + outlist.join('\\n');\n}\n\nvar context_diff = function(hunk) {\n  var s = '***************\\n';\n  s = s + '*** ' + context_range(hunk, 'old') + ' ****\\n';\n  // Retrieve the context\n  var r = context_range(hunk, 'new');\n  var outlist = null;\n  \n  // Print out file 1 part for each block in context diff format if there\n  // are any blocks that remove items\n  var lo = hunk.start_old;\n  var hi = hunk.end_old;\n  var removes = hunk.blocks.filter(function(e) { return !(e.remove.length == 0); });\n  \n  if(removes) {\n    outlist = hunk.data_old.slice(lo, hi).map(function(e) { return e.replace(/^/g, '  '); });\n    removes.forEach(function(block) {\n      block.remove.forEach(function(item) {\n        outlist[item.position - lo] = outlist[item.position - lo].replace(/^ /g, block.op); // - or !\n      });\n    });\n    // Add to diff string\n    s = s + outlist.join('\\n');\n  }\n  \n  s = s + '\\n-- ' + r + ' ----\\n';\n  lo = hunk.start_new;\n  hi = hunk.end_new;\n  var inserts = hunk.blocks.filter(function(e) { return !(e.insert.length == 0); });\n\n  if(inserts) {\n    outlist = hunk.data_new.slice(lo, hi).map(function(e) { return e.replace(/^/g, '  '); });\n    inserts.forEach(function(block) {\n      block.insert.forEach(function(item) {\n        outlist[item.position - lo] = outlist[item.position - lo].replace(/^ /g, block.op); // + or !\n      });\n    });\n    // Add to diff string\n    s = s + outlist.join('\\n');    \n  }\n  // Return the diff string\n  return s;\n}\n\nvar ed_diff = function(hunk, format) {\n  var opt_act = {'+':'a', '-':'d', '!':'c'};\n  if(hunk.blocks.length > 1) sys.puts(\"expecting only one block in an old diff hunk!\");\n  var s = null;\n  \n  if(format == 'reverse_ed') {\n    s = \"\" + op_act[hunk.blocks[0].op] + context_range(hunk, 'old') + '\\n';\n  } else {\n    s = \"\" + context_range(hunk, 'old').replace(/,/g, ' ') + op_act[hunk.blocks[0].op] + '\\n';\n  }\n  \n  if(hunk.blocks[0].insert.length > 0) {\n    hunk.data_new.slice(hunk.start_new, hunk.end_new).forEach(function(e) {\n      s = s + '' + e + '\\n';\n    });\n    // Add final marker\n    s = s + '.\\n';\n  }\n  // Return diff string\n  return s;\n}\n\n// Generate a range of item numbers to print. Only print 1 number if the\n// range has only one item in it. Otherwise, it's 'start,end'\nvar context_range = function(hunk, mode) {\n  var s = null, e = null;\n  \n  if(mode == 'old') {\n    s = (hunk.start_old + 1);\n    e = (hunk.end_old + 1);\n  } else if(mode == 'new') {\n    s = (hunk.start_new + 1);\n    e = (hunk.end_new + 1);    \n  }\n  \n  return (s < e) ? (\"\" + s + \",\" + e) : (\"\" + e);\n}\n\n// Generate a range of item numbers to print for unified diff. Print\n// number where block starts, followed by number of lines in the block\n// (don't print number of lines if it's 1)\nvar unified_range = function(hunk, mode) {\n  var s = null, e = null;\n  \n  if(mode == 'old') {\n    s = (hunk.start_old + 1);\n    e = (hunk.end_old + 1);\n  } else if(mode == 'new') {\n    s = (hunk.start_new + 1);\n    e = (hunk.end_new + 1);\n  }\n  \n  var length = e - s + 1;\n  var first = (length < 2) ? e : s;   // something weird   \n  return (length == 1) ? (\"\" + first) : (first + \",\" + length);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/diff/block.js":"// A block is an operation removing, adding, or changing a group of items.\n// Basically, this is just a list of changes, where each change adds or\n// deletes a single item. Used by bin/ldiff.\nvar Block = exports.Block = function(chunk) {\n  this.changes = [];\n  this.insert = [];\n  this.remove = [];\n  var self = this;\n  \n  chunk.forEach(function(item) {\n    self.changes.push(item);\n    if(item.is_deleting()) self.remove.push(item);\n    if(item.is_adding()) self.insert.push(item);\n  })  \n  \n  Object.defineProperty(this, \"diff_size\", { get: function() { return self.insert.length - self.remove.length; }, enumerable: true});      \n  Object.defineProperty(this, \"op\", { get: function() { \n    var result = [self.remove.length == 0, self.insert.length == 0];\n\n    if(!result[0] && !result[1]) {\n      return \"!\";\n    } else if(!result[0] && result[1]) {\n      return \"-\";\n    } else if(result[0] && result[1]) {\n      return \"+\";\n    } else {\n      return \"^\";\n    }\n  }, enumerable: true});      \n}\n\nBlock.prototype.op = function() {\n}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/git_index.js":"var util = require('util'),\n  Tree = require('./tree').Tree,\n  Config = require('./config').Config;\n\nvar GitIndex = exports.GitIndex = function(repo) {  \n  var _repo = repo, _tree = {}, _current_tree = null;\n  \n  Object.defineProperty(this, \"tree\", { get: function() { return _tree; }, set: function(value) { _tree = value; }, enumerable: true});    \n  Object.defineProperty(this, \"current_tree\", { get: function() { return _current_tree; }, set: function(value) { _current_tree = value; }, enumerable: true});    \n  Object.defineProperty(this, \"repo\", { get: function() { return _repo; }, set: function(value) { _repo = value; }, enumerable: true});  \n}\n\n// Sets the current tree\n//  +tree+ the branch/tag/sha... to use - a string\n// \n// Returns index (self)\nGitIndex.prototype.read_tree = function(tree, callback) {\n  var self = this;\n  // Load the tree\n  this.repo.tree(tree, function(err, loaded_tree) {\n    if(err) return callback(err, loaded_tree);\n    self.current_tree = loaded_tree;\n    callback(null, loaded_tree);\n  })\n}\n\n// Add a file to the index\n//   +path+ is the path (including filename)\n//   +data+ is the binary contents of the file\n//\n// Returns nothing\nGitIndex.prototype.add = function(file_path, data) {\n  var path = file_path.split('/');\n  var filename = path.pop();  \n  var current = this.tree;\n  \n  path.forEach(function(dir) {\n    current[dir] = current[dir] || {};\n    var node = current[dir];\n    current = node;\n  });\n    \n  current[filename] = data;\n}\n\n// Commit the contents of the index\n//   +message+ is the commit message [nil]\n//   +parents+ is one or more commits to attach this commit to to form a new head [nil]\n//   +actor+ is the details of the user making the commit [nil]\n//   +last_tree+ is a tree to compare with - to avoid making empty commits [nil]\n//   +head+ is the branch to write this head to [master]\n//\n// Returns a String of the SHA1 of the commit\nGitIndex.prototype.commit = function(message, parents, actor, last_tree, head, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  // Set variables to default values\n  parents = args.length ? args.shift() : null;  \n  actor = args.length ? args.shift() : null;  \n  last_tree = args.length ? args.shift() : null;  \n  head = args.length ? args.shift() : 'master'; \n  \n  this.write_tree(this.tree, this.current_tree, function(err, tree_sha1) {\n    if(tree_sha1 == last_tree) return callback(null, false);  // Don't write identical commits\n    var contents = [];\n    // Add tree to contents\n    contents.push(['tree', tree_sha1].join(' '));\n    // Add all parents if they exist\n    if(parents) {\n      parents.forEach(function(p) {\n        if(p) contents.push(['parent', p].join(' '));\n      });\n    }\n    \n    // Define name and email\n    var name = null, email = null;\n    \n    if(actor) {\n      name = actor.name;\n      email = actor.email;\n    } else {\n      config = new Config(self.repo);\n      name = config['user.name'];\n      email = config['user.email'];      \n    }\n    \n    var author_string = \"\" + name + \" <\" + email + \"> \" + parseInt(new Date().getTime()/1000) + \" -0700\";  // TODO must fix\n    contents.push(['author', author_string].join(' '));\n    contents.push(['committer', author_string].join(' '));\n    contents.push('');\n    contents.push(message);\n    // Write commit and update reference tree\n    self.repo.git.put_raw_object(contents.join(\"\\n\"), 'commit', function (commit_sha1) {\n      self.repo.update_ref(head, commit_sha1, callback);\n    });\n  });\n}\n\nvar to_bin = function(sha1o) {\n  var sha1 = '';\n  for(var i = 0; i < sha1o.length; i = i + 2) {\n    sha1 = sha1 + String.fromCharCode(parseInt(sha1o.substr(i, 2), 16));\n  }  \n  return sha1;\n}\n\n// Recursively write a tree to the index\n//   +tree+ is the tree\n//\n// Returns the SHA1 String of the tree\nGitIndex.prototype.write_tree = function(tree, now_tree, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  // Set variables to default values\n  now_tree = args.length ? args.shift() : null;  \n  \n  // Holds the tree content\n  var tree_contents = {};\n  \n  // Fill in the original tree\n  if(now_tree) {\n    now_tree.contents.forEach(function(obj) {\n      var sha = to_bin(obj.id);\n      var k = obj.name;\n      \n      if(obj instanceof Tree) k = k + '/';\n      tree_contents[k] = \"\" + obj.mode.toString() + \" \" + obj.name + \"\\0\" + sha;\n    });\n  }\n  \n  // overwrite with the new tree contents\n  Object.keys(tree).forEach(function(key) {\n    var value = tree[key];\n    \n    if(value.constructor == String) {\n      var sha = self.write_blob(value);      \n      sha = to_bin(sha);\n      tree_contents[key] = \"\" + '100644' + \" \" + key + '\\0' + sha;\n    } else if(Object.prototype.toString.call(value) === '[object Object]') {      \n      var ctree = now_tree ? (now_tree.find(key)) : null;\n      // Write the next level\n      self.write_tree(value, ctree, function(err, sha) {\n        var sha = to_bin(sha);\n        tree_contents[key + '/'] = \"\" + '040000' + \" \" + key + '\\0' + sha;        \n      });      \n    }\n  })\n  \n  var tr = Object.keys(tree_contents).sort().map(function(key) {\n    return tree_contents[key];\n  }).join('');\n  \n  // Return the object sha\n  this.repo.git.put_raw_object(tr, 'tree', function (sha1) {\n    callback(null, sha1);\n  })\n}\n\n// Write the blob to the index\n//   +data+ is the data to write\n//\n// Returns the SHA1 String of the blob\nGitIndex.prototype.write_blob = function(data) {  \n  return this.repo.git.put_raw_object(data, 'blob');\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/head.js":"var util = require('util'),\n  Commit = require('./commit').Commit;\n\nvar Head = exports.Head = function(name, commit) {\n  var _name = name;\n  var _commit = commit;  \n  // Define the properties\n  Object.defineProperty(this, \"name\", { get: function() { return _name; }, enumerable: true});\n  Object.defineProperty(this, \"commit\", { get: function() { return _commit; }, enumerable: true});\n}\n\nvar prefix = function(name) { \n    return \"refs/\" + name + \"s\"; \n  }\n  \nHead.current = function(repo, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};  \n  // Let's read the the head\n  repo.git.fs_read('HEAD', function(err, head) {\n    if(err) return callback(err, head);\n    var matches = head.toString().match(/ref: refs\\/heads\\/(.*)/);\n    if(!matches) return callback(null, null);\n    // we have a correct reference, create a new head reference\n    repo.git.rev_parse(options, 'HEAD', 0, function(err, rev) {\n      if(err) return callback(err, rev);\n      return callback(null, new Head(matches[1], rev));\n    });\n  });\n}\n\nHead.find_all = function(repo, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n  // Let's fetch the references\n  repo.git.refs({}, prefix('head'), function(err, refs) {    \n    if(err) return callback(err, refs);\n    // Map the references\n    var mapped_refs = refs.split(/\\n/).map(function(ref) {\n      // Fetch the name and id for the reference\n      var split_reference = ref.split(/ /);\n      var name = split_reference[0];\n      var id = split_reference[1];\n      \n      // Create a commit object wit the id\n      var commit = new Commit(repo, id);\n      // Wrap the commit object in a head object and return mapped object\n      return new Head(name, commit);\n    })    \n    callback(null, mapped_refs);\n  })\n}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/merge.js":"var Merge = exports.Merge = function(str) {\n  var _conflicts = 0, _text = {}, _sections = null;\n  var section = 0;\n  var status = Merge.STATUS_BOTH;\n  \n  Object.defineProperty(this, \"conflicts\", { get: function() { return _conflicts; }, set: function(value) { _conflicts = value; }, enumerable: true});    \n  Object.defineProperty(this, \"text\", { get: function() { return _text; }, set: function(value) { _text = value; }, enumerable: true});    \n  Object.defineProperty(this, \"sections\", { get: function() { return _sections; }, set: function(value) { _sections = value; }, enumerable: true});    \n\n  var lines = str.split(\"\\n\");\n  lines.forEach(function(line) {\n    if(line.match(/^<<<<<<< (.*?)/)) {\n      status = Merge.STATUS_OURS;\n      _conflicts = _conflicts + 1;\n      section = section + 1;\n    } else if(line == '=======') {\n      status = Merge.STATUS_THEIRS;\n    } else if(line.match(/^>>>>>>> (.*?)/)) {\n      status = Merge.STATUS_BOTH;\n      section = section + 1;\n    } else {\n      _text[section] = _text[section] == null ? {} : _text[section];\n      _text[section][status] = _text[section][status] == null ? [] : _text[section][status];\n      _text[section][status].push(line);\n    }    \n  });\n  \n  // Let's set the values\n  _text = Object.keys(_text).map(function(key) {\n    return _text[key];\n  });\n  // Set the number of sections\n  _sections = _text.length;\n}\n\n// Static function\nMerge.STATUS_BOTH = 'both';\nMerge.STATUS_OURS = 'ours';\nMerge.STATUS_THEIRS = 'theirs';\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/ref.js":"var Ref = exports.Ref = function() {}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/remote.js":"var Commit = require('./commit').Commit;\n\nvar Remote = exports.Remote = function(name, commit) {\n  var _name = name;\n  var _commit = commit;  \n  // Define the properties\n  Object.defineProperty(this, \"name\", { get: function() { return _name; }, enumerable: true});\n  Object.defineProperty(this, \"commit\", { get: function() { return _commit; }, enumerable: true});\n}\n\nvar prefix = function(name) { \n    return \"refs/\" + name + \"s\"; \n  }\n\nRemote.find_all = function(repo, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n  \n  // Let's fetch the references\n  repo.git.refs({}, prefix('remote'), function(err, refs) {    \n    if(err) return callback(err, refs);\n    // Map the references\n    var mapped_refs = refs.split(/\\n/).map(function(ref) {\n      // Fetch the name and id for the reference\n      var split_reference = ref.split(/ /);\n      var name = split_reference[0];\n      var id = split_reference[1];\n      \n      // Create a commit object wit the id\n      var commit = new Commit(repo, id);\n      // Wrap the commit object in a head object and return mapped object\n      return new Remote(name, commit);\n    })    \n    callback(null, mapped_refs);\n  })  \n}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/repo.js":"var Head = require('./head').Head,\n  Git = require('./git').Git,\n  Commit = require('./commit').Commit,\n  fs = require('fs'),\n  util = require('util'),\n  Tree = require('./tree').Tree,\n  Blob = require('./blob').Blob,\n  Head = require('./head').Head,\n  Tag = require('./tag').Tag,\n  Remote = require('./remote').Remote,\n  Blame = require('./blame').Blame,\n  CommitStats = require('./commit_stats').CommitStats,\n  Config = require('./config').Config,\n  Status = require('./status').Status,\n  GitIndex = require('./git_index').GitIndex;\n\nvar Repo = exports.Repo = function(path, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n\n  var _path = path;\n  var _options = options;\n  var _working_directory = _path;\n  var _bare = true;\n  var _git = null;\n  var _config_object = null;\n  // Create git object\n  var self = this;\n  // Control access to internal variables\n  Object.defineProperty(this, \"path\", { get: function() { return _path; }, enumerable: true});\n  Object.defineProperty(this, \"options\", { get: function() { return _options; }, enumerable: true});\n  Object.defineProperty(this, \"git\", { get: function() { return _git; }, enumerable: true});\n  Object.defineProperty(this, \"config_object\", { get: function() { return _config_object; }, enumerable: true});\n  Object.defineProperty(this, \"bare\", { get: function() { return _bare; }, enumerable: true});\n  Object.defineProperty(this, \"working_directory\", { get: function() { return _working_directory; }, enumerable: true});\n\n  try {\n    var epath = fs.realpathSync(path);\n    // Todo checks on paths\n    fs.stat(epath + \"/.git\", function(err, stat) {\n      if(!err) {\n        _working_directory = epath;\n        _path = epath + \"/.git\";\n        _bare = false;\n        _git = new Git(_path);\n        // Return the repo\n        callback(null, self);\n      } else {\n        // Check if it's a bare or already is pointing to the .git directory\n        fs.stat(epath, function(err, stat) {\n          if(!err && stat.isDirectory() && (epath.match(/\\.git$/) || options.is_bare)) {\n            _path = epath;\n            _bare = true;\n            _git = new Git(_path);\n            // Return the repo\n            callback(null, self);\n          } else if(!err && stat.isDirectory()) {\n            callback(\"invalid git repository\", null);\n          } else {\n            callback(\"no such path\", null);\n          }\n        });\n      }\n    });\n  } catch (err) {\n    callback(\"no such path\", null);\n  }\n}\n\n// Fetch the current head\nRepo.prototype.head = function(callback) {\n  Head.current(this, callback);\n}\n\n// Fetch the repo heads\nRepo.prototype.heads = function(callback) {\n  Head.find_all(this, callback);\n}\n\n// Returns the tag objects that are available in this repo\nRepo.prototype.tags = function(callback) {\n  Tag.find_all(this, callback);\n}\n\n// Fetch a set of commits\nRepo.prototype.commits = function(start, max_count, skip, callback) {\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  start = args.length ? args.shift() : 'master';\n  max_count = args.length ? args.shift() : 10;\n  skip = args.length ? args.shift() : 0;\n\n  var options = {max_count:max_count, skip:skip}\n  // Locate all commits with the specified options\n  Commit.find_all(this, start, options, callback);\n}\n\n// Fetch a specific commit\nRepo.prototype.commit = function(id, callback) {\n  var options = {max_count:1};\n  // Locate commits and return the first one\n  Commit.find_all(this, id, options, function(err, commits) {\n    if(err) return callback(err, commits);\n    callback(null, commits[0]);\n  })\n}\n\n// Fetch the commit count based on a start reference\nRepo.prototype.commit_count = function(start, callback) {\n  start = start ? start : 'master';\n  Commit.count(this, start, callback);\n}\n\n// Fetch a repository tree\nRepo.prototype.tree = function(treeish, paths, callback) {\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  // Set variables to default values\n  treeish = args.length ? args.shift() : 'master';\n  paths = args.length ? args.shift() : [];\n  // Construct the tree\n  Tree.construct(this, treeish, paths, callback);\n}\n\n// Create a blob object\nRepo.prototype.blob = function(id, callback) {\n  callback(null, new Blob(this, id));\n}\n\n// Initialize a bare git repository at the given path\n//  path: full path to the repo (traditionally ends with /<name>.git)\n//  options: is any additional options to the git init command\n//\n// Examples\n//  Repo.init_bare('/var/git/myrepo.git')\n//\n// Return repo (newly created repo)\nRepo.init_bare = function(path, git_options, repo_options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  // Set variables to default values\n  git_options = args.length ? args.shift() : {};\n  repo_options = repo_options ? repo_options : {};\n  // Set up bare option\n  git_options['bare'] = true;\n  repo_options['is_bare'] = true;\n  // Create a git object\n  var git = new Git(path);\n  // Create the directory\n  git.fs_mkdir('', function(err, result) {\n    if(err) return callback(err, result);\n    git.init(git_options, function(err, git) {\n      if(err) return callback(err, git);\n      new Repo(path, repo_options, callback);\n    })\n  })\n}\n\n// Fork a bare git repository from this repo\n//  path: is the full path of the new repo (traditionally ends with /<name>.git)\n//  options: is additional options to the git clone command (:bare and :shared are true by default)\n//\n// Return repo (newly created forked repo)\nRepo.prototype.fork_bare = function(path, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  var self = this;\n  // Set variables to default values\n  options = args.length ? args.shift() : {};\n  options['bare'] = true;\n  options['shared'] = true;\n  // Create a git object\n  var git = new Git(path);\n  git.fs_mkdir('', function(err, result) {\n    if(err) return callback(err, result);\n    self.git.clone(options, self.path, path, function(err, result) {\n      if(err) return callback(err, result);\n      new Repo(path, {is_bare:true}, callback);\n    })\n  })\n}\n\n// The diff from commit a to commit b, optionally restricted to the fiven file(s)\n//  a: the base commit\n//  b: the end commit\n//  paths: optional list of file paths on which to restrict the diff\nRepo.prototype.diff = function(a, b, paths, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 0); // XXX doesnt seem correct but it works for me\n  callback = args.pop();\n  b = args.length ? args.shift() : null;\n  paths = args.length ? args.shift() : [];\n\n  Commit.diff(this, a, b, paths, callback);\n}\n\n// The commit diff for the given commit\n//  commit: the commit name/id\n//\n// Returns array of diff objects\nRepo.prototype.commit_diff = function(commit, callback) {\n  Commit.diff(this, commit, callback);\n}\n\n// The list of alternates for this repo\n//\n// Returns array of string (pathnames of alternates)\nRepo.prototype.alternates = function(callback) {\n  var alternates_path = \"objects/info/alternates\";\n  var self = this;\n\n  this.git.fs_exist(alternates_path, function(err, result) {\n    if(err) return callback(err, result);\n    if(!result) return callback(null, []);\n    self.git.fs_read(alternates_path, function(err, data) {\n      if(err) return callback(err, data);\n      callback(null, data.trim().split(\"\\n\"));\n    })\n  });\n}\n\n// Sets the alternates\n//  alts: array of string paths representing the alternates\n//\n// Returns nothing\nRepo.prototype.set_alternates = function(alts, callback) {\n  var self = this;\n  var fail_msg = null;\n  // check all the entries\n  for(var i = 0; i < alts.length; i++) {\n\n    // Is sync underneath (to avoid to many files open)\n    this.git.fs_exist(alts[i], function(err, result) {\n      if(err) fail_msg = err;\n      if(!result) fail_msg = \"could not set alternates. alternate path \" + alts[i] + \" must exist\";\n    });\n  }\n\n  // If we have a fail message return\n  if(fail_msg) { return callback(fail_msg, null); }\n  // Otherwise let's set the alternate\n  if(alts.length == 0) {\n    this.git.fs_write('objects/info/alternates', '', callback);\n  } else {\n    this.git.fs_write('objects/info/alternates', alts.join(\"\\n\"), callback);\n  }\n}\n\n// The commit log for a treeish\n//\n// Returns array of commits\nRepo.prototype.log = function(commit, path, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  var self = this;\n  // Unpack variables\n  commit = args.length ? args.shift() : 'master';\n  path = args.length ? args.shift() : null;\n  options = args.length ? args.shift() : {};\n  // Merge in extra parameters\n  options['pretty'] = \"raw\";\n  // var arg = path ? [commit, '--', path] : [commit];\n  // Extract the commits\n  this.git.log(commit, path, options, function(err, commits) {\n    if(err) return callback(err, commits);\n    callback(null, Commit.list_from_string(self, commits))\n  });\n}\n\n// Returns a list of commits that is in other_repo but not in self\n//\n// Returns array of commits\nRepo.prototype.commit_deltas_from = function(other_repo, reference, other_reference, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  var self = this;\n  // Unpack variables\n  reference = args.length ? args.shift() : 'master';\n  other_reference = args.length ? args.shift() : 'master';\n  // Let's fetch revlist\n  self.git.rev_list({}, reference, function(err, rev_text) {\n    if(err) return callback(err, rev_text);\n    var repo_refs = rev_text.trim().split(\"\\n\");\n\n    other_repo.git.rev_list({}, other_reference, function(err, other_rev_text) {\n      if(err) return callback(err, other_rev_text);\n      var other_repo_refs = other_rev_text.trim().split(\"\\n\");\n\n      // Subtract the references from other references\n      // create map for the array to avoid binary searches\n      var repo_ref_map = {};\n      repo_refs.forEach(function(line) {\n        repo_ref_map[line] = 1;\n      });\n\n      // Subtract one array from the other\n      var intersection = other_repo_refs.filter(function(line) { return !repo_ref_map[line]; })\n      // Returned commits\n      var commits = [];\n      // Process all the intersected values\n      for(var i = 0; i < intersection.length; i++) {\n        var ref = intersection[i];\n        Commit.find_all(other_repo, ref, {max_count:1}, function(err, ref_commits) {\n          commits.push(ref_commits[0]);\n        })\n      }\n\n      // Return the commits\n      callback(null, commits);\n    })\n  });\n}\n\n// An array of ref objects representing the refs in this repo\n//\n// Returns array of references (baked)\nRepo.prototype.refs = function(callback) {\n  var self = this;\n  // Let's fetch all the references for the head\n  Head.find_all(self, function(err, head_refs) {\n    if(err) return callback(err, head_refs);\n    // Fetch all the references for the tags\n    Tag.find_all(self, function(err, tag_refs) {\n      if(err) return callback(err, tag_refs);\n      // Fetch all the remote references\n      Remote.find_all(self, function(err, remote_refs) {\n        if(err) return callback(err, remote_refs);\n        // Return the complete list of references\n        callback(null, head_refs.concat(tag_refs, remote_refs));\n      });\n    });\n  });\n}\n\n// Chomp text removing end carriage returns\nvar chomp = function chomp(raw_text) {\n  return raw_text.replace(/(\\n|\\r)+$/, '');\n}\n\n// The project's description, Taken directly from /description file in the repo\n//\n// Return string\nRepo.prototype.description = function(callback) {\n  this.git.fs_read('description', function(err, data) {\n    if(err) return callback(err, data);\n    callback(null, chomp(data.toString()));\n  });\n}\n\n// Update a reference\n//  head: reference name\n//  commit_sha: commit to update\n//\n// Return commit_sha\nRepo.prototype.update_ref = function(head, commit_sha, callback) {\n  if(!commit_sha || commit_sha.length != 40) return callback('not a legal commit sha', null);\n  this.git.fs_write(\"refs/heads/\" + head, commit_sha, function(err, result) {\n    if(err) return callback(err, result);\n    callback(null, commit_sha);\n  });\n}\n\n// Get a specific head by name\n//  head_name: name of the head\n//\n// Return the head object\nRepo.prototype.get_head = function(head_name, callback) {\n  this.heads(function(err, heads) {\n    if(err) return callback(err, heads);\n    for(var i = 0; i < heads.length; i++) {\n      if(heads[i].name == head_name) return callback(null, heads[i])\n    }\n    // No head found\n    callback(null, null);\n  });\n}\n\n// Return a blam object\n//  file: name of file we want to locate blame for\n//  commit: the commit sha for the blame\n//\n// Return blame object\nRepo.prototype.blame = function(file, commit, callback) {\n  new Blame(this, file, commit, callback);\n}\n\n// Returns a stats object about the commits for the repo\n//  start: start commit or name\n//  max_count: maximum count traversing\n//  skip: Number of commits to skip\nRepo.prototype.commit_stats = function(start, max_count, skip, callback) {\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  var self = this;\n  // Unpack variables\n  start = args.length ? args.shift() : 'master';\n  max_count = args.length ? args.shift() : 10;\n  skip = args.length ? args.shift() : 0;\n\n  // Build options hash\n  var options = {max_count:max_count, skip:skip};\n  // Fetch all the commit stats\n  CommitStats.find_all(self, start, options, callback);\n}\n\n// Commits current index\n//\n// Return true/false if commit worked\nRepo.prototype.commit_index = function(message, callback) {\n  this.git.commit({}, '-m' + message, callback);\n}\n\n// Commits all tracked and modified files\n//\n// Return true/false if commit worked\nRepo.prototype.commit_all = function(message, callback) {\n  this.git.commit({}, '-a', '-m' + message, callback);\n}\n\n// Fetch the config for the repo\n//\n// Returns assoc array with config options\nRepo.prototype.config = function(callback) {\n  if(this.config_object) return callback(null, this.config_object);\n  callback(null, new Config(this));\n}\n\n// Gotten from\nvar flatten = function(array) {\n  return array.reduce(function(a,b) {\n    return a.concat(b);\n  }, []);\n}\n\n// Adds files to the index\nRepo.prototype.add = function(files, callback) {\n  var flattened_files = null;\n  // Let's unpack the variables\n  var args = Array.prototype.slice.call(arguments, 0);\n  // Pop the callback\n  var callback = args.pop();\n\n  if(Array.isArray(files)) {\n    flattened_files = flatten(files);\n  } else if(args.length > 1){\n    flattened_files = flatten(args);\n  } else {\n    flattened_files = [files];\n  }\n  // Add the parameters\n  flattened_files.unshift({});\n  flattened_files.push(callback);\n  // Execut add function against git repo\n  this.git.add.apply(this.git, flattened_files);\n}\n\n// Removes files to the index\nRepo.prototype.remove = function(files, callback) {\n  var flattened_files = null;\n  // Let's unpack the variables\n  var args = Array.prototype.slice.call(arguments, 0);\n  // Pop the callback\n  var callback = args.pop();\n\n  if(Array.isArray(files)) {\n    flattened_files = flatten(files);\n  } else if(args.length > 1){\n    flattened_files = flatten(args);\n  } else {\n    flattened_files = [files];\n  }\n  // Add the parameters\n  flattened_files.unshift({});\n  flattened_files.push(callback);\n  // Execut add function against git repo\n  this.git.remove.apply(this.git, flattened_files);\n}\n\n// Fetch repo status\nRepo.prototype.status = function(callback) {\n  new Status(this, callback);\n}\n\n// Array off Remote objects representing the remote branches in\n// this repo\n//\n// Return array of remote references (baked)\nRepo.prototype.remotes = function(callback) {\n  Remote.find_all(this, callback);\n}\n\n// Validate if something is a head\n//\n// Return head\nRepo.prototype.is_head = function(head_name, callback) {\n  this.get_head(head_name, function(err, head) {\n    if(err) return callback(err, head);\n    var exists = head == null ? false : true;\n    callback(null, exists);\n  });\n}\n\nRepo.prototype.index = function(callback) {\n  callback(null, new GitIndex(this));\n}\n\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/tag.js":"var Commit = require('./commit').Commit;\n\nvar Tag = exports.Tag = function(name, commit) {\n  var _name = name;\n  var _commit = commit;  \n  // Define the properties\n  Object.defineProperty(this, \"name\", { get: function() { return _name; }, enumerable: true});\n  Object.defineProperty(this, \"commit\", { get: function() { return _commit; }, enumerable: true});\n}\n\nvar prefix = function(name) { \n    return \"refs/\" + name + \"s\"; \n  }\n\nTag.find_all = function(repo, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n  \n  // Let's fetch the references\n  repo.git.refs({}, prefix('tag'), function(err, refs) {    \n    if(err) return callback(err, refs);\n    if(!refs) return callback(null, []);\n    // Map the references\n    var mapped_refs = refs.split(/\\n/).map(function(ref) {\n      // Fetch the name and id for the reference\n      var split_reference = ref.split(/ /);\n      var name = split_reference[0];\n      var id = split_reference[1];\n      // Ensure we have the right id (if it's a tag it's the actual commit of the tag not the tag id)\n      var cid = repo.git.commit_from_sha(id)\n      if(cid == '') throw \"unknown object type\";\n      // Create a commit object wit the id\n      var commit = new Commit(repo, cid);\n      // Wrap the commit object in a head object and return mapped object\n      return new Tag(name, commit);        \n    })    \n    \n    callback(null, mapped_refs);\n  })  \n}\n","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/status.js":"var util = require('util'),\n  GitFileOperations = require('./git_file_operations').GitFileOperations,\n  StatusFile = require('./status_file').StatusFile;\n\nvar Status = exports.Status = function(repo, callback) {\n  var _repo = repo, _files = [];\n  \n  Object.defineProperty(this, \"repo\", { get: function() { return _repo; }, set: function(value) { _repo = value; }, enumerable: false});\n  Object.defineProperty(this, \"files\", { get: function() { return _files; }, set: function(value) { _files = value; }, enumerable: true});\n  \n  construct_status(_repo, this, callback);\n}\n\nStatus.prototype.index = function(file) {\n  return this.files[file];\n}\n\n// Construct the status object\nvar construct_status = function(repo, status, callback) {\n  // Let's get the files list\n  ls_files(repo, function(err, repo_files) {\n    if(err) return callback(err, repo_files);\n    // Set the basic list of files\n    status.files = repo_files;\n    // Fetch all the untracked files in working directory and add them to the list of files\n    locate_untracked_files(repo.working_directory, status, function(err, untracked_files) {\n      if(err) return callback(err, untracked_files);\n      \n      // Find modified files in tree\n      diff_files(repo, function(err, diff_files) {\n        if(err) return callback(err, diff_files);\n        \n        // Process all the files, merging in any extra information where needed\n        Object.keys(diff_files).forEach(function(key) {\n          if(status.files[key]) {\n            for(var attrname in diff_files[key]) { status.files[key][attrname] = diff_files[key][attrname]; }\n          } else {\n            status.files[key] = diff_files[key];\n          }\n        })\n        \n        // Find added but not commited -- new files\n        diff_index(repo, 'HEAD', function(err, added_files) {\n          if(err) return callback(err, added_files);\n\n          // Process all the files, merging in any extra information where needed\n          Object.keys(added_files).forEach(function(key) {\n            if(status.files[key]) {\n              for(var attrname in added_files[key]) { status.files[key][attrname] = added_files[key][attrname]; }\n            } else {\n              status.files[key] = added_files[key];\n            }\n          })\n          \n          // Now process all the file objects and replace them with real status file objects\n          Object.keys(status.files).forEach(function(key) {\n            status.files[key] = new StatusFile(repo, status.files[key]);\n          })\n          \n          // Return the populated status object\n          callback(null, status);\n        });\n      });\n    })\n  })\n}\n\n// Locate all the diff files in the repo\nvar diff_files = function(repo, callback) {\n  var hsh = {};\n  \n  repo.git.diff_files(function(err, lines_output) {\n    var lines = lines_output.split(\"\\n\");\n\n    lines.forEach(function(line) {\n      var parts = line.split(\"\\t\");\n      // Unpack the line\n      var info = parts[0], file = parts[1];\n      parts = info.trim().replace(/ +/g, ' ').split(\" \");\n      // Unpack the parts from the info\n      var mode_src = parts[0], mode_dest = parts[1], sha_src = parts[2], sha_dest = parts[3], type = parts[4]\n      hsh[file] = {path:file, mode_file:mode_src.toString().substr(1, 7), mode_index:mode_dest,\n                    sha_file:sha_src, sha_index:sha_dest, type:type};      \n    });\n\n    callback(null, hsh);\n  });  \n}\n\n// Compares the index and the repository\nvar diff_index = function(repo, tree_sha, callback) {  \n  var hsh = {};\n\n  repo.git.diff_index({}, tree_sha, function(err, lines_output) {\n    var lines = lines_output.split(\"\\n\");\n\n    lines.forEach(function(line) {\n      var parts = line.split(\"\\t\");\n      // Unpack the line\n      var info = parts[0], file = parts[1];\n      parts = info.trim().replace(/ +/g, ' ').split(\" \");\n      // Unpack the parts from the info\n      var mode_src = parts[0], mode_dest = parts[1], sha_src = parts[2], sha_dest = parts[3], type = parts[4];\n      hsh[file] = {path:file, mode_repo:mode_src.toString().substr(1, 7), mode_index:mode_dest,\n                    sha_repo:sha_src, sha_index:sha_dest, type:type};      \n    });\n\n    callback(null, hsh);\n  });    \n}\n\n// Get the list of all files that are tracked in the repo\nvar ls_files = function(repo, callback) {\n  var hsh = {};\n\n  repo.git.ls_files({stage:true}, function(err, lines_output) {\n    var lines = lines_output.split(\"\\n\");\n\n    lines.forEach(function(line) {\n      var parts = line.split(\"\\t\");\n      // Unpack the line\n      var info = parts[0], file = parts[1];\n      parts = info.trim().replace(/ +/g, ' ').split(\" \");\n      // Unpack the parts from the info\n      var mode = parts[0], sha = parts[1], stage = parts[2];\n      hsh[file] = {path:file, mode_index:mode, sha_index:sha, stage:stage};      \n    });\n\n    callback(null, hsh);\n  })\n}\n\n// Locates all the untracked files in the repo\nvar locate_untracked_files = function(directory, status, callback) {\n  var files = status.files;\n  // Locate all files in underlying directories\n  var stream = GitFileOperations.glob_streaming(directory);  \n  // Triggers on each entry in the directory\n  stream.addListener(\"data\", function(result) {\n    if(files[result.path] == null && result.stat.isFile()) {\n      var file = result.path.replace(directory + \"/\", '');\n      files[file] = {path:file, untracked:true};\n    }\n  });\n  \n  // Triggers at the end of the call\n  stream.addListener(\"end\", function(err, result) {\n    callback(null, files);\n  })  \n}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/lib/git/status_file.js":"var util = require('util');\n\nvar StatusFile = exports.StatusFile = function(repo , hash) {\n  var _repo = repo;\n  var _path = hash.path, _type = hash.type, _stage = hash.stage, _mode_index = hash.mode_index;\n  var _mode_repo = hash.mode_repo, _sha_index = hash.sha_index, _sha_repo = hash.sha_repo, _untracked = hash.untracked;\n\n  Object.defineProperty(this, \"repo\", { get: function() { return _repo; }, set: function(value) { _repo = value; }, enumerable: false});\n\n  Object.defineProperty(this, \"path\", { get: function() { return _path; }, set: function(value) { _path = value; }, enumerable: true});\n  Object.defineProperty(this, \"type\", { get: function() { return _type; }, set: function(value) { _type = value; }, enumerable: true});\n  Object.defineProperty(this, \"stage\", { get: function() { return _stage; }, set: function(value) { _stage = value; }, enumerable: true});\n  Object.defineProperty(this, \"mode_index\", { get: function() { return _mode_index; }, set: function(value) { _mode_index = value; }, enumerable: true});\n  Object.defineProperty(this, \"mode_repo\", { get: function() { return _mode_repo; }, set: function(value) { _mode_repo = value; }, enumerable: true});\n  Object.defineProperty(this, \"sha_index\", { get: function() { return _sha_index; }, set: function(value) { _sha_index = value; }, enumerable: true});\n  Object.defineProperty(this, \"sha_repo\", { get: function() { return _sha_repo; }, set: function(value) { _sha_repo = value; }, enumerable: true});\n  Object.defineProperty(this, \"untracked\", { get: function() { return _untracked; }, set: function(value) { _untracked = value; }, enumerable: true});  \n}","/home/travis/build/npmtest/node-npmtest-git/node_modules/git/benchmarks/benchmark.js":"\nvar Repo = require('git/repo').Repo,\n  util = require('util'),\n  fs = require('fs'),\n  exec  = require('child_process').exec;\n\nvar number_of_executions = 30;\n\nvar create_tmp_directory = function(clone_path, callback) {\n  var filename = 'git_test' + new Date().getTime().toString() + Math.round((Math.random(100000) * 300)).toString();\n  var tmp_path = '/tmp/' + filename;\n  // Create directory\n  fs.mkdirSync(tmp_path, 0777);\n  // Copy the old directory to the new one\n  var child = exec('cp -R ' + clone_path + ' ' + tmp_path, function (error, stdout, stderr) {\n      if (error !== null) {\n        util.puts('exec error: ' + error);\n        return callback(error, null);\n      }\n      return callback(null, tmp_path);\n  });\n}\n\nvar destroy_directory = function(directory, callback) {\n  // Copy the old directory to the new one\n  var child = exec('rm -rf ' + directory, function (error, stdout, stderr) {\n      if (error !== null) {\n        util.puts('exec error: ' + error);\n        return callback(error, null);\n      }\n      return callback(null, null);    \n  });  \n}\n\nvar commit1 = '5e3ee1198672257164ce3fe31dea3e40848e68d5'\nvar commit2 = 'ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a'\n\nvar pack_object_function = function(repo) {  \n  repo.commit('5e3ee1198672257164ce3fe31dea3e40848e68d5', function(err, commit) {\n    repo.tree('cd7422af5a2e0fff3e94d6fb1a8fff03b2841881', function(err, tree) {\n      repo.blob('4232d073306f01cf0b895864e5a5cfad7dd76fce', function(err, blob) {\n        commit.parents[0].parents[0].parents[0];\n      })\n    })\n  });  \n}\n\nvar commits1_function = function(repo) {\n  repo.commits(function(err, commits) {\n    commits.length;\n  })\n}\n\nvar commits2_function = function(repo) {\n  repo.commits('master', 15, function(err, log) {\n    log.length;\n    log.length;\n    log[0];\n    repo.commits('testing', function(err, commits) {\n      commits.map(function(c) { return c.message; });\n    })\n  })\n}\n\nvar big_revlist_function = function(repo) {\n  repo.commits('master', 200, function(err, commits) {});\n}\n\nvar log_function = function(repo) {\n  repo.log('master', function(err, log) {\n    log.length;\n    log.length;\n    log[0];\n  })\n}\n\nvar diff_function = function(repo) {\n  repo.diff(commit1, commit2, function(err, diff) {});\n}\n\nvar commit_diff_function = function(repo) {\n  repo.commit_diff(commit1, function(err, diff) {});\n}\n\nvar heads_function = function(repo) {\n  repo.heads(function(err, heads) {\n    heads.map(function(b) { return b.commit.id; });\n  });\n}\n\nvar execute_process = function(type) {\n  var execute_function = null;\n  \n  // Check that we have the right function\n  if(type == \"packobj\") {\n    execute_function = pack_object_function;\n  } else if(type == \"commits1\") {\n    execute_function = commits1_function;\n  } else if(type == \"commits2\") {\n    execute_function = commits2_function;\n  } else if(type == \"big_revlist\") {\n    execute_function = big_revlist_function;\n  } else if(type == \"log\") {\n    execute_function = log_function;\n  } else if(type == \"diff\") {\n    execute_function = diff_function;\n  } else if(type == \"commit_diff\") {\n    execute_function = commit_diff_function;\n  } else if(type == \"heads\") {\n    execute_function = heads_function;\n  }\n\n  // Ensure that we have an executable function\n  if(execute_function) {\n    // Creat temp directory\n    create_tmp_directory(\"/Users/christian.kvalheim/coding/checkouts/grit/test/dot_git\", function(err, target_path) {\n      // Open the repo\n      new Repo(target_path + \"/dot_git\", {is_bare:true}, function(err, repo) {\n        var start_time = new Date();\n        \n        // Execute the benchmark x number of times if a function is defined\n        for(var i = 0; i < number_of_executions; i++) {\n          execute_function(repo);\n        }     \n        \n        var end_time = new Date();\n        var total_miliseconds = end_time.getTime() - start_time.getTime();\n        util.puts(\"[\" + type + \"]::executed in: \" + (total_miliseconds/1000) + \" seconds\");        \n        // Delete the directory\n        destroy_directory(target_path, function(err, result) {});\n      });      \n    });\n  }  \n}\n\nif(process.argv.length > 2 && process.argv[2].match(/packobj|commits1|commits2|big_revlist|log|diff|commit_diff|heads|all/)) {\n  if(process.argv[2] == \"all\") {\n    var tests = [\"packobj\", \"commits1\", \"commits2\", \"big_revlist\", \"log\", \"diff\", \"commit_diff\", \"heads\"];\n    // var tests = [\"packobj\", \"commits1\", \"commits2\", \"big_revlist\", \"log\"];\n    tests.forEach(function(t) {\n      execute_process(t);\n    })\n  } else {\n    execute_process(process.argv[2]);\n  }  \n} else {\n  util.puts(\"Please provide the benchmark you wish to run in the form <node benchmarks [packobj|commits1|commits2|big_revlist|log|diff|commit_diff|heads|all]>\")\n}\n  \n\n"}